{
    "bench_arrayexprs.ArrayExpressions.time_cube_float32": {
        "code": "class <locals>:\n    def f(self):\n        f = getattr(self, func)\n        f(*self.samples[dtype])\n\ndef setup():\n    ArrayExpressions.setupClass()\n\nclass ArrayExpressions:\n    def setup(self):\n        from numba import jit\n    \n        jitter = jit(nopython=True)\n        self.sum = jitter(sum)\n        self.sq_diff = jitter(sq_diff)\n        self.rel_diff = jitter(rel_diff)\n        self.square = jitter(square)\n        self.cube = jitter(cube)",
        "min_run_count": 2,
        "name": "bench_arrayexprs.ArrayExpressions.time_cube_float32",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1151032abb1a474047d75729df99dd3d8747e03d4286942f01814ef3596b355f",
        "warmup_time": -1
    },
    "bench_arrayexprs.ArrayExpressions.time_cube_float64": {
        "code": "class <locals>:\n    def f(self):\n        f = getattr(self, func)\n        f(*self.samples[dtype])\n\ndef setup():\n    ArrayExpressions.setupClass()\n\nclass ArrayExpressions:\n    def setup(self):\n        from numba import jit\n    \n        jitter = jit(nopython=True)\n        self.sum = jitter(sum)\n        self.sq_diff = jitter(sq_diff)\n        self.rel_diff = jitter(rel_diff)\n        self.square = jitter(square)\n        self.cube = jitter(cube)",
        "min_run_count": 2,
        "name": "bench_arrayexprs.ArrayExpressions.time_cube_float64",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1151032abb1a474047d75729df99dd3d8747e03d4286942f01814ef3596b355f",
        "warmup_time": -1
    },
    "bench_arrayexprs.ArrayExpressions.time_rel_diff_float32": {
        "code": "class <locals>:\n    def f(self):\n        f = getattr(self, func)\n        f(*self.samples[dtype])\n\ndef setup():\n    ArrayExpressions.setupClass()\n\nclass ArrayExpressions:\n    def setup(self):\n        from numba import jit\n    \n        jitter = jit(nopython=True)\n        self.sum = jitter(sum)\n        self.sq_diff = jitter(sq_diff)\n        self.rel_diff = jitter(rel_diff)\n        self.square = jitter(square)\n        self.cube = jitter(cube)",
        "min_run_count": 2,
        "name": "bench_arrayexprs.ArrayExpressions.time_rel_diff_float32",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1151032abb1a474047d75729df99dd3d8747e03d4286942f01814ef3596b355f",
        "warmup_time": -1
    },
    "bench_arrayexprs.ArrayExpressions.time_rel_diff_float64": {
        "code": "class <locals>:\n    def f(self):\n        f = getattr(self, func)\n        f(*self.samples[dtype])\n\ndef setup():\n    ArrayExpressions.setupClass()\n\nclass ArrayExpressions:\n    def setup(self):\n        from numba import jit\n    \n        jitter = jit(nopython=True)\n        self.sum = jitter(sum)\n        self.sq_diff = jitter(sq_diff)\n        self.rel_diff = jitter(rel_diff)\n        self.square = jitter(square)\n        self.cube = jitter(cube)",
        "min_run_count": 2,
        "name": "bench_arrayexprs.ArrayExpressions.time_rel_diff_float64",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1151032abb1a474047d75729df99dd3d8747e03d4286942f01814ef3596b355f",
        "warmup_time": -1
    },
    "bench_arrayexprs.ArrayExpressions.time_sq_diff_float32": {
        "code": "class <locals>:\n    def f(self):\n        f = getattr(self, func)\n        f(*self.samples[dtype])\n\ndef setup():\n    ArrayExpressions.setupClass()\n\nclass ArrayExpressions:\n    def setup(self):\n        from numba import jit\n    \n        jitter = jit(nopython=True)\n        self.sum = jitter(sum)\n        self.sq_diff = jitter(sq_diff)\n        self.rel_diff = jitter(rel_diff)\n        self.square = jitter(square)\n        self.cube = jitter(cube)",
        "min_run_count": 2,
        "name": "bench_arrayexprs.ArrayExpressions.time_sq_diff_float32",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1151032abb1a474047d75729df99dd3d8747e03d4286942f01814ef3596b355f",
        "warmup_time": -1
    },
    "bench_arrayexprs.ArrayExpressions.time_sq_diff_float64": {
        "code": "class <locals>:\n    def f(self):\n        f = getattr(self, func)\n        f(*self.samples[dtype])\n\ndef setup():\n    ArrayExpressions.setupClass()\n\nclass ArrayExpressions:\n    def setup(self):\n        from numba import jit\n    \n        jitter = jit(nopython=True)\n        self.sum = jitter(sum)\n        self.sq_diff = jitter(sq_diff)\n        self.rel_diff = jitter(rel_diff)\n        self.square = jitter(square)\n        self.cube = jitter(cube)",
        "min_run_count": 2,
        "name": "bench_arrayexprs.ArrayExpressions.time_sq_diff_float64",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1151032abb1a474047d75729df99dd3d8747e03d4286942f01814ef3596b355f",
        "warmup_time": -1
    },
    "bench_arrayexprs.ArrayExpressions.time_square_float32": {
        "code": "class <locals>:\n    def f(self):\n        f = getattr(self, func)\n        f(*self.samples[dtype])\n\ndef setup():\n    ArrayExpressions.setupClass()\n\nclass ArrayExpressions:\n    def setup(self):\n        from numba import jit\n    \n        jitter = jit(nopython=True)\n        self.sum = jitter(sum)\n        self.sq_diff = jitter(sq_diff)\n        self.rel_diff = jitter(rel_diff)\n        self.square = jitter(square)\n        self.cube = jitter(cube)",
        "min_run_count": 2,
        "name": "bench_arrayexprs.ArrayExpressions.time_square_float32",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1151032abb1a474047d75729df99dd3d8747e03d4286942f01814ef3596b355f",
        "warmup_time": -1
    },
    "bench_arrayexprs.ArrayExpressions.time_square_float64": {
        "code": "class <locals>:\n    def f(self):\n        f = getattr(self, func)\n        f(*self.samples[dtype])\n\ndef setup():\n    ArrayExpressions.setupClass()\n\nclass ArrayExpressions:\n    def setup(self):\n        from numba import jit\n    \n        jitter = jit(nopython=True)\n        self.sum = jitter(sum)\n        self.sq_diff = jitter(sq_diff)\n        self.rel_diff = jitter(rel_diff)\n        self.square = jitter(square)\n        self.cube = jitter(cube)",
        "min_run_count": 2,
        "name": "bench_arrayexprs.ArrayExpressions.time_square_float64",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1151032abb1a474047d75729df99dd3d8747e03d4286942f01814ef3596b355f",
        "warmup_time": -1
    },
    "bench_arrayexprs.ArrayExpressions.time_sum_float32": {
        "code": "class <locals>:\n    def f(self):\n        f = getattr(self, func)\n        f(*self.samples[dtype])\n\ndef setup():\n    ArrayExpressions.setupClass()\n\nclass ArrayExpressions:\n    def setup(self):\n        from numba import jit\n    \n        jitter = jit(nopython=True)\n        self.sum = jitter(sum)\n        self.sq_diff = jitter(sq_diff)\n        self.rel_diff = jitter(rel_diff)\n        self.square = jitter(square)\n        self.cube = jitter(cube)",
        "min_run_count": 2,
        "name": "bench_arrayexprs.ArrayExpressions.time_sum_float32",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1151032abb1a474047d75729df99dd3d8747e03d4286942f01814ef3596b355f",
        "warmup_time": -1
    },
    "bench_arrayexprs.ArrayExpressions.time_sum_float64": {
        "code": "class <locals>:\n    def f(self):\n        f = getattr(self, func)\n        f(*self.samples[dtype])\n\ndef setup():\n    ArrayExpressions.setupClass()\n\nclass ArrayExpressions:\n    def setup(self):\n        from numba import jit\n    \n        jitter = jit(nopython=True)\n        self.sum = jitter(sum)\n        self.sq_diff = jitter(sq_diff)\n        self.rel_diff = jitter(rel_diff)\n        self.square = jitter(square)\n        self.cube = jitter(cube)",
        "min_run_count": 2,
        "name": "bench_arrayexprs.ArrayExpressions.time_sum_float64",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1151032abb1a474047d75729df99dd3d8747e03d4286942f01814ef3596b355f",
        "warmup_time": -1
    },
    "bench_blackscholes.BlackScholes.time_blackscholes": {
        "code": "class BlackScholes:\n    def time_blackscholes(self):\n        for i in range(10):\n            blackscholes(*args)\n\ndef setup():\n    \"\"\"\n    Precompile jitted functions.\n    \"\"\"\n    global cnd, blackscholes\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def cnd(d):\n        K = 1.0 / (1.0 + 0.2316419 * math.fabs(d))\n        ret_val = (RSQRT2PI * math.exp(-0.5 * d * d) *\n                (K * (A1 + K * (A2 + K * (A3 + K * (A4 + K * A5))))))\n        if d > 0:\n            ret_val = 1.0 - ret_val\n        return ret_val\n\n\n    @jit(nopython=True)\n    def blackscholes(callResult, putResult, stockPrice, optionStrike,\n                    optionYears, Riskfree, Volatility):\n        S = stockPrice\n        X = optionStrike\n        T = optionYears\n        R = Riskfree\n        V = Volatility\n        for i in range(len(S)):\n            sqrtT = math.sqrt(T[i])\n            d1 = (math.log(S[i] / X[i]) + (R + 0.5 * V * V) * T[i]) / (V * sqrtT)\n            d2 = d1 - V * sqrtT\n            cndd1 = cnd(d1)\n            cndd2 = cnd(d2)\n\n            expRT = math.exp((-1. * R) * T[i])\n            callResult[i] = (S[i] * cndd1 - X[i] * expRT * cndd2)\n            putResult[i] = (X[i] * expRT * (1.0 - cndd2) - S[i] * (1.0 - cndd1))\n\n\n\n    blackscholes(*args)",
        "min_run_count": 2,
        "name": "bench_blackscholes.BlackScholes.time_blackscholes",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "713317b9a430aef49eeec252abe1094c762b66cb0a4bfe98c94d411aec759716",
        "warmup_time": -1
    },
    "bench_centdiff.CenteredDifference.time_centered_difference_1d": {
        "code": "class CenteredDifference:\n    def time_centered_difference_1d(self):\n        centered_difference_range1d(u1, D1, dx)\n\ndef setup():\n    global centered_difference_range1d, centered_difference_range2d\n    from numba import jit\n\n    @jit(nopython=True)\n    def centered_difference_range1d(u, D, dx=1.):\n        m, = u.shape\n        for i in range(1, m - 1):\n            D[i] = (u[i-1] + u[i+1] - 2.0*u[i]) / dx**2\n        return D\n\n    @jit(nopython=True)\n    def centered_difference_range2d(u, D, dx=1.):\n        m, n = u.shape\n        for i in range(1, m - 1):\n            for j in range(1, n - 1):\n                D[i,j] = (u[i+1,j] + u[i,j+1] + u[i-1,j] + u[i,j-1] - 4.0*u[i,j]) / dx**2\n        return D",
        "min_run_count": 2,
        "name": "bench_centdiff.CenteredDifference.time_centered_difference_1d",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "346a30e261ca79ed2cda69d7b874027c6421aa74ec323be016703c840bda9e48",
        "warmup_time": -1
    },
    "bench_centdiff.CenteredDifference.time_centered_difference_2d_C": {
        "code": "class CenteredDifference:\n    def time_centered_difference_2d_C(self):\n        centered_difference_range2d(u2c, D2c, dx)\n\ndef setup():\n    global centered_difference_range1d, centered_difference_range2d\n    from numba import jit\n\n    @jit(nopython=True)\n    def centered_difference_range1d(u, D, dx=1.):\n        m, = u.shape\n        for i in range(1, m - 1):\n            D[i] = (u[i-1] + u[i+1] - 2.0*u[i]) / dx**2\n        return D\n\n    @jit(nopython=True)\n    def centered_difference_range2d(u, D, dx=1.):\n        m, n = u.shape\n        for i in range(1, m - 1):\n            for j in range(1, n - 1):\n                D[i,j] = (u[i+1,j] + u[i,j+1] + u[i-1,j] + u[i,j-1] - 4.0*u[i,j]) / dx**2\n        return D",
        "min_run_count": 2,
        "name": "bench_centdiff.CenteredDifference.time_centered_difference_2d_C",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "4931b9a5724f1867b2f4289eec02d0b52b757cfe4c7b0772043836f4064252eb",
        "warmup_time": -1
    },
    "bench_centdiff.CenteredDifference.time_centered_difference_2d_fortran": {
        "code": "class CenteredDifference:\n    def time_centered_difference_2d_fortran(self):\n        centered_difference_range2d(u2f, D2f, dx)\n\ndef setup():\n    global centered_difference_range1d, centered_difference_range2d\n    from numba import jit\n\n    @jit(nopython=True)\n    def centered_difference_range1d(u, D, dx=1.):\n        m, = u.shape\n        for i in range(1, m - 1):\n            D[i] = (u[i-1] + u[i+1] - 2.0*u[i]) / dx**2\n        return D\n\n    @jit(nopython=True)\n    def centered_difference_range2d(u, D, dx=1.):\n        m, n = u.shape\n        for i in range(1, m - 1):\n            for j in range(1, n - 1):\n                D[i,j] = (u[i+1,j] + u[i,j+1] + u[i-1,j] + u[i,j-1] - 4.0*u[i,j]) / dx**2\n        return D",
        "min_run_count": 2,
        "name": "bench_centdiff.CenteredDifference.time_centered_difference_2d_fortran",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d178f6a31b51aff3e8d3271dd2e2718fdff8298e5ccc8d985acdf1e37049d02b",
        "warmup_time": -1
    },
    "bench_centdiff.CenteredDifference.time_centered_difference_2d_non_contiguous": {
        "code": "class CenteredDifference:\n    def time_centered_difference_2d_non_contiguous(self):\n        centered_difference_range2d(u2a, D2a, dx)\n\ndef setup():\n    global centered_difference_range1d, centered_difference_range2d\n    from numba import jit\n\n    @jit(nopython=True)\n    def centered_difference_range1d(u, D, dx=1.):\n        m, = u.shape\n        for i in range(1, m - 1):\n            D[i] = (u[i-1] + u[i+1] - 2.0*u[i]) / dx**2\n        return D\n\n    @jit(nopython=True)\n    def centered_difference_range2d(u, D, dx=1.):\n        m, n = u.shape\n        for i in range(1, m - 1):\n            for j in range(1, n - 1):\n                D[i,j] = (u[i+1,j] + u[i,j+1] + u[i-1,j] + u[i,j-1] - 4.0*u[i,j]) / dx**2\n        return D",
        "min_run_count": 2,
        "name": "bench_centdiff.CenteredDifference.time_centered_difference_2d_non_contiguous",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "6444f2b118b6fa213f3e6b588a26bae278754d3c7f3a52e09ffff5c0b6e709b3",
        "warmup_time": -1
    },
    "bench_compiling.CachedCompilation.time_jit_mandel": {
        "code": "class CachedCompilation:\n    def time_jit_mandel(self):\n        jit(mandel_sig, cache=True, nopython=True)(mandel)\n\ndef setup():\n    global jit\n    from numba import jit\n\nclass CachedCompilation:\n    def setup_cache(self):\n        from numba import jit\n        # Ensure the functions are cached into the ASV environment\n        # before running the actual benchmark methods.\n        jit(mandel_sig, cache=True, nopython=True)(mandel)\n        jit(\"int32(int32)\", cache=True, nopython=True)(no_op)",
        "min_run_count": 2,
        "name": "bench_compiling.CachedCompilation.time_jit_mandel",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "setup_cache_key": "/Users/vhaenel/git/numba-benchmark/benchmarks/bench_compiling.py:73",
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "31e72bce638c21023b9d4c26195cd4ebdcccda552a431270eeb06ea18f550ea3",
        "warmup_time": -1
    },
    "bench_compiling.CachedCompilation.time_jit_noop": {
        "code": "class CachedCompilation:\n    def time_jit_noop(self):\n        jit(\"int32(int32)\", cache=True, nopython=True)(no_op)\n\ndef setup():\n    global jit\n    from numba import jit\n\nclass CachedCompilation:\n    def setup_cache(self):\n        from numba import jit\n        # Ensure the functions are cached into the ASV environment\n        # before running the actual benchmark methods.\n        jit(mandel_sig, cache=True, nopython=True)(mandel)\n        jit(\"int32(int32)\", cache=True, nopython=True)(no_op)",
        "min_run_count": 2,
        "name": "bench_compiling.CachedCompilation.time_jit_noop",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "setup_cache_key": "/Users/vhaenel/git/numba-benchmark/benchmarks/bench_compiling.py:73",
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "20b3b035b520c679bebebe1398a47ea9d0dd85cf0c412ab08e98a5e167f1f57d",
        "warmup_time": -1
    },
    "bench_compiling.LoopLiftedCompilation.time_lift": {
        "code": "class LoopLiftedCompilation:\n    def time_lift(self):\n        # The only way to time the entire thing (including the inner\n        # function formed by the loop) is to call the function wrapper.\n        f = jit(lift)\n        f(1.0)\n\ndef setup():\n    global jit\n    from numba import jit",
        "min_run_count": 2,
        "name": "bench_compiling.LoopLiftedCompilation.time_lift",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "fdd062a3b3282be795df2896e8f64900902cda619a91af87de528cfcd6cb3d6b",
        "warmup_time": -1
    },
    "bench_compiling.NoPythonCompilation.time_jit_mandel": {
        "code": "class NoPythonCompilation:\n    def time_jit_mandel(self):\n        jit(mandel_sig, nopython=True)(mandel)\n\ndef setup():\n    global jit\n    from numba import jit",
        "min_run_count": 2,
        "name": "bench_compiling.NoPythonCompilation.time_jit_mandel",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1a619b88830330f5ce3ee18f2c92ec41a5cdb1f549bb441fdb0303f8cfd63fa0",
        "warmup_time": -1
    },
    "bench_compiling.NoPythonCompilation.time_jit_noop": {
        "code": "class NoPythonCompilation:\n    def time_jit_noop(self):\n        jit(\"int32(int32)\", nopython=True)(no_op)\n\ndef setup():\n    global jit\n    from numba import jit",
        "min_run_count": 2,
        "name": "bench_compiling.NoPythonCompilation.time_jit_noop",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "0aa9d7870a50c68f04ab9c981ce12208e1f430afb8c51c681e91cddca7a056af",
        "warmup_time": -1
    },
    "bench_compiling.PyObjectCompilation.time_jit_mandel_forceobj": {
        "code": "class PyObjectCompilation:\n    def time_jit_mandel_forceobj(self):\n        jit(mandel_sig, forceobj=True, looplift=False)(mandel)\n\ndef setup():\n    global jit\n    from numba import jit",
        "min_run_count": 2,
        "name": "bench_compiling.PyObjectCompilation.time_jit_mandel_forceobj",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "697ed3240cacc08c5e1479c724a1345999f5d28441492f772cd6a37e87660793",
        "warmup_time": -1
    },
    "bench_compiling.PyObjectCompilation.time_jit_noop_fallback": {
        "code": "class PyObjectCompilation:\n    def time_jit_noop_fallback(self):\n        jit(\"int32(int32)\")(force_obj)\n\ndef setup():\n    global jit\n    from numba import jit",
        "min_run_count": 2,
        "name": "bench_compiling.PyObjectCompilation.time_jit_noop_fallback",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1923c71bd4f2e278762785b7e4b762a4bd1baf051a1e92f45c224e30b1b53ba2",
        "warmup_time": -1
    },
    "bench_compiling.PyObjectCompilation.time_jit_noop_forceobj": {
        "code": "class PyObjectCompilation:\n    def time_jit_noop_forceobj(self):\n        jit(\"int32(int32)\", forceobj=True)(force_obj)\n\ndef setup():\n    global jit\n    from numba import jit",
        "min_run_count": 2,
        "name": "bench_compiling.PyObjectCompilation.time_jit_noop_forceobj",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "4d86add590e9e4c9935ba4d707e3fb334dcce473a57798f3b446114457ebeb30",
        "warmup_time": -1
    },
    "bench_cuda.BlackScholes.time_blackscholes": {
        "code": "class BlackScholes:\n    def time_blackscholes(self):\n        blockdim = 512, 1\n        griddim = int(math.ceil(float(N) / blockdim[0])), 1\n        for i in range(10):\n            black_scholes_cuda[griddim, blockdim, self.stream](\n                self.d_callResult, self.d_putResult,\n                self.d_stockPrice, self.d_optionStrike, self.d_optionYears,\n                RISKFREE, VOLATILITY)\n        self.stream.synchronize()\n\ndef setup():\n    _jit_setup1()\n    _jit_setup2()\n\nclass BlackScholes:\n    def setup(self):\n        self.stream = cuda.stream()\n        self.d_callResult = cuda.to_device(callResultGold, self.stream)\n        self.d_putResult = cuda.to_device(putResultGold, self.stream)\n        self.d_stockPrice = cuda.to_device(stockPrice, self.stream)\n        self.d_optionStrike = cuda.to_device(optionStrike, self.stream)\n        self.d_optionYears = cuda.to_device(optionYears, self.stream)\n        self.stream.synchronize()",
        "min_run_count": 2,
        "name": "bench_cuda.BlackScholes.time_blackscholes",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "4a457708adad4165a73f676965e3d4bb544b2e02bbc9944ebb5397fbb1493d97",
        "warmup_time": -1
    },
    "bench_cuda.DataTransfer.time_transfer_from_gpu_large": {
        "code": "class DataTransfer:\n    def time_transfer_from_gpu_large(self):\n        for i in range(10):\n            self.d_large_data.copy_to_host(self.large_data, self.stream)\n        self.stream.synchronize()\n\ndef setup():\n    _jit_setup1()\n    _jit_setup2()\n\nclass DataTransfer:\n    def setup(self):\n        self.stream = cuda.stream()\n        self.small_data = np.zeros(512, dtype=np.float64)\n        self.large_data = np.zeros(512 * 1024, dtype=np.float64)\n        self.d_small_data = cuda.to_device(self.small_data, self.stream)\n        self.d_large_data = cuda.to_device(self.large_data, self.stream)\n        self.stream.synchronize()",
        "min_run_count": 2,
        "name": "bench_cuda.DataTransfer.time_transfer_from_gpu_large",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "627ef5f5c0cab131d4bdb52bd9cc299c93195c054cf4f9f1dd6984189f318573",
        "warmup_time": -1
    },
    "bench_cuda.DataTransfer.time_transfer_from_gpu_small": {
        "code": "class DataTransfer:\n    def time_transfer_from_gpu_small(self):\n        for i in range(10):\n            self.d_small_data.copy_to_host(self.small_data, self.stream)\n        self.stream.synchronize()\n\ndef setup():\n    _jit_setup1()\n    _jit_setup2()\n\nclass DataTransfer:\n    def setup(self):\n        self.stream = cuda.stream()\n        self.small_data = np.zeros(512, dtype=np.float64)\n        self.large_data = np.zeros(512 * 1024, dtype=np.float64)\n        self.d_small_data = cuda.to_device(self.small_data, self.stream)\n        self.d_large_data = cuda.to_device(self.large_data, self.stream)\n        self.stream.synchronize()",
        "min_run_count": 2,
        "name": "bench_cuda.DataTransfer.time_transfer_from_gpu_small",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "e05c66672408a57598ab202ec459859c32903b3eb4c138f2382909fea0acba57",
        "warmup_time": -1
    },
    "bench_cuda.DataTransfer.time_transfer_to_gpu_large": {
        "code": "class DataTransfer:\n    def time_transfer_to_gpu_large(self):\n        for i in range(10):\n            cuda.to_device(self.large_data, self.stream)\n        self.stream.synchronize()\n\ndef setup():\n    _jit_setup1()\n    _jit_setup2()\n\nclass DataTransfer:\n    def setup(self):\n        self.stream = cuda.stream()\n        self.small_data = np.zeros(512, dtype=np.float64)\n        self.large_data = np.zeros(512 * 1024, dtype=np.float64)\n        self.d_small_data = cuda.to_device(self.small_data, self.stream)\n        self.d_large_data = cuda.to_device(self.large_data, self.stream)\n        self.stream.synchronize()",
        "min_run_count": 2,
        "name": "bench_cuda.DataTransfer.time_transfer_to_gpu_large",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "e92aeef7a46c8f1ae4858791b2a95483195f85cd6b481c31ddae0210786ca557",
        "warmup_time": -1
    },
    "bench_cuda.DataTransfer.time_transfer_to_gpu_small": {
        "code": "class DataTransfer:\n    def time_transfer_to_gpu_small(self):\n        for i in range(10):\n            cuda.to_device(self.small_data, self.stream)\n        self.stream.synchronize()\n\ndef setup():\n    _jit_setup1()\n    _jit_setup2()\n\nclass DataTransfer:\n    def setup(self):\n        self.stream = cuda.stream()\n        self.small_data = np.zeros(512, dtype=np.float64)\n        self.large_data = np.zeros(512 * 1024, dtype=np.float64)\n        self.d_small_data = cuda.to_device(self.small_data, self.stream)\n        self.d_large_data = cuda.to_device(self.large_data, self.stream)\n        self.stream.synchronize()",
        "min_run_count": 2,
        "name": "bench_cuda.DataTransfer.time_transfer_to_gpu_small",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "579d23ce90eda6dfbe8856731832783b31bb12ba3445d01f9938233aaf1e0916",
        "warmup_time": -1
    },
    "bench_cuda.NBody.time_cpu_nbody": {
        "code": "class NBody:\n    def time_cpu_nbody(self):\n        run_cpu_nbody(self.positions, self.weights)\n\ndef setup():\n    _jit_setup1()\n    _jit_setup2()\n\nclass NBody:\n    def setup(self):\n        # Sanity check our implementation\n        p, w = make_nbody_samples(tile_size * 2)\n        runner = NBodyCUDARunner(p, w)\n        runner.run()\n        cuda_res = runner.results()\n        cpu_res = run_cpu_nbody(p, w)\n        assert np.allclose(cuda_res, cpu_res, 1e-4), (cuda_res, cpu_res)\n        # Make actual benchmark samples and prepare data transfer\n        self.positions, self.weights = make_nbody_samples(self.n_bodies)\n        self.runner = NBodyCUDARunner(self.positions, self.weights)",
        "min_run_count": 2,
        "name": "bench_cuda.NBody.time_cpu_nbody",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "bd1b3a45b9aada49d32ae28fdc3fd31b672f09b6a9fb9b5179b59572eb30cebe",
        "warmup_time": -1
    },
    "bench_cuda.NBody.time_cuda_nbody": {
        "code": "class NBody:\n    def time_cuda_nbody(self):\n        self.runner.run()\n\ndef setup():\n    _jit_setup1()\n    _jit_setup2()\n\nclass NBody:\n    def setup(self):\n        # Sanity check our implementation\n        p, w = make_nbody_samples(tile_size * 2)\n        runner = NBodyCUDARunner(p, w)\n        runner.run()\n        cuda_res = runner.results()\n        cpu_res = run_cpu_nbody(p, w)\n        assert np.allclose(cuda_res, cpu_res, 1e-4), (cuda_res, cpu_res)\n        # Make actual benchmark samples and prepare data transfer\n        self.positions, self.weights = make_nbody_samples(self.n_bodies)\n        self.runner = NBodyCUDARunner(self.positions, self.weights)",
        "min_run_count": 2,
        "name": "bench_cuda.NBody.time_cuda_nbody",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "5b4c25c6c67d0a1be4e141104c929a892b7ca63fafc8b85e344bb223ba5e0667",
        "warmup_time": -1
    },
    "bench_cuda.Synthetic.time_addmul_f32": {
        "code": "class Synthetic:\n    def time_addmul_f32(self):\n        blockdim = 512, 1\n        griddim = int(math.ceil(float(self.n) / blockdim[0])), 1\n        for i in range(10):\n            addmul_f32[griddim, blockdim, self.stream](\n                self.d_f32, self.d_f32, self.d_f32)\n        self.stream.synchronize()\n\ndef setup():\n    _jit_setup1()\n    _jit_setup2()\n\nclass Synthetic:\n    def setup(self):\n        self.no_op = cuda.jit(argtypes=())(no_op)\n        self.stream = cuda.stream()\n        self.f32 = np.zeros(self.n, dtype=np.float32)\n        self.d_f32 = cuda.to_device(self.f32, self.stream)\n        self.f64 = np.zeros(self.n, dtype=np.float64)\n        self.d_f64 = cuda.to_device(self.f64, self.stream)\n        self.sum_reduce = cuda.reduce(lambda x, y: x+y)\n        self.res_f32 = cuda.to_device(np.zeros(1, dtype=np.float32))\n        self.res_f64 = cuda.to_device(np.zeros(1, dtype=np.float64))\n        self.stream.synchronize()",
        "min_run_count": 2,
        "name": "bench_cuda.Synthetic.time_addmul_f32",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "3d4d84e0ba35073275b596474bddf0ba09bb2f0761d7317f398b7af972224d81",
        "warmup_time": -1
    },
    "bench_cuda.Synthetic.time_addmul_f64": {
        "code": "class Synthetic:\n    def time_addmul_f64(self):\n        blockdim = 512, 1\n        griddim = int(math.ceil(float(self.n) / blockdim[0])), 1\n        for i in range(10):\n            addmul_f64[griddim, blockdim, self.stream](\n                self.d_f64, self.d_f64, self.d_f64)\n        self.stream.synchronize()\n\ndef setup():\n    _jit_setup1()\n    _jit_setup2()\n\nclass Synthetic:\n    def setup(self):\n        self.no_op = cuda.jit(argtypes=())(no_op)\n        self.stream = cuda.stream()\n        self.f32 = np.zeros(self.n, dtype=np.float32)\n        self.d_f32 = cuda.to_device(self.f32, self.stream)\n        self.f64 = np.zeros(self.n, dtype=np.float64)\n        self.d_f64 = cuda.to_device(self.f64, self.stream)\n        self.sum_reduce = cuda.reduce(lambda x, y: x+y)\n        self.res_f32 = cuda.to_device(np.zeros(1, dtype=np.float32))\n        self.res_f64 = cuda.to_device(np.zeros(1, dtype=np.float64))\n        self.stream.synchronize()",
        "min_run_count": 2,
        "name": "bench_cuda.Synthetic.time_addmul_f64",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d40df27c87a924c27c65502e6f24001107ab6cac083e272405d436d5f1e4c4cb",
        "warmup_time": -1
    },
    "bench_cuda.Synthetic.time_reduce_f32": {
        "code": "class Synthetic:\n    def time_reduce_f32(self):\n        self.sum_reduce(self.d_f32, res=self.res_f32, stream=self.stream)\n        self.stream.synchronize()\n\ndef setup():\n    _jit_setup1()\n    _jit_setup2()\n\nclass Synthetic:\n    def setup(self):\n        self.no_op = cuda.jit(argtypes=())(no_op)\n        self.stream = cuda.stream()\n        self.f32 = np.zeros(self.n, dtype=np.float32)\n        self.d_f32 = cuda.to_device(self.f32, self.stream)\n        self.f64 = np.zeros(self.n, dtype=np.float64)\n        self.d_f64 = cuda.to_device(self.f64, self.stream)\n        self.sum_reduce = cuda.reduce(lambda x, y: x+y)\n        self.res_f32 = cuda.to_device(np.zeros(1, dtype=np.float32))\n        self.res_f64 = cuda.to_device(np.zeros(1, dtype=np.float64))\n        self.stream.synchronize()",
        "min_run_count": 2,
        "name": "bench_cuda.Synthetic.time_reduce_f32",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b52d9ff3d4bb96858a6cce2e71bdce2c5394c0326322f980d7d6d23d4516b8fe",
        "warmup_time": -1
    },
    "bench_cuda.Synthetic.time_reduce_f64": {
        "code": "class Synthetic:\n    def time_reduce_f64(self):\n        self.sum_reduce(self.d_f64, res=self.res_f64, stream=self.stream)\n        self.stream.synchronize()\n\ndef setup():\n    _jit_setup1()\n    _jit_setup2()\n\nclass Synthetic:\n    def setup(self):\n        self.no_op = cuda.jit(argtypes=())(no_op)\n        self.stream = cuda.stream()\n        self.f32 = np.zeros(self.n, dtype=np.float32)\n        self.d_f32 = cuda.to_device(self.f32, self.stream)\n        self.f64 = np.zeros(self.n, dtype=np.float64)\n        self.d_f64 = cuda.to_device(self.f64, self.stream)\n        self.sum_reduce = cuda.reduce(lambda x, y: x+y)\n        self.res_f32 = cuda.to_device(np.zeros(1, dtype=np.float32))\n        self.res_f64 = cuda.to_device(np.zeros(1, dtype=np.float64))\n        self.stream.synchronize()",
        "min_run_count": 2,
        "name": "bench_cuda.Synthetic.time_reduce_f64",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "42c187dd3a477b110fae4e2210aecb9822d93705b2bb757cbf554ccd50a03532",
        "warmup_time": -1
    },
    "bench_cuda.Synthetic.time_run_empty_kernel": {
        "code": "class Synthetic:\n    def time_run_empty_kernel(self):\n        self.no_op[1, 1, self.stream]()\n        self.stream.synchronize()\n\ndef setup():\n    _jit_setup1()\n    _jit_setup2()\n\nclass Synthetic:\n    def setup(self):\n        self.no_op = cuda.jit(argtypes=())(no_op)\n        self.stream = cuda.stream()\n        self.f32 = np.zeros(self.n, dtype=np.float32)\n        self.d_f32 = cuda.to_device(self.f32, self.stream)\n        self.f64 = np.zeros(self.n, dtype=np.float64)\n        self.d_f64 = cuda.to_device(self.f64, self.stream)\n        self.sum_reduce = cuda.reduce(lambda x, y: x+y)\n        self.res_f32 = cuda.to_device(np.zeros(1, dtype=np.float32))\n        self.res_f64 = cuda.to_device(np.zeros(1, dtype=np.float64))\n        self.stream.synchronize()",
        "min_run_count": 2,
        "name": "bench_cuda.Synthetic.time_run_empty_kernel",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "9831057d2f0c86594e2f83dfec1fac2da4310283a0b8f1618f9652c77673ac36",
        "warmup_time": -1
    },
    "bench_dispatch.NoPythonDispatch.time_dispatch_array_1d": {
        "code": "class <locals>:\n    def timefunc(self, arg=samples[name]):\n        func = binary\n        for i in range(1000):\n            func(arg, arg)\n\ndef setup():\n    \"\"\"\n    Precompile jitted functions.  This will register many specializations\n    to choose from.\n    \"\"\"\n    from numba import jit\n    global binary, binary_pyobj, unary_default\n\n    @jit(nopython=True)\n    def binary(x, y):\n        pass\n\n    @jit(forceobj=True)\n    def binary_pyobj(x, y):\n        pass\n\n    @jit(nopython=True)\n    def unary_default(x=None):\n        pass\n\n    for tp in samples.values():\n        binary(tp, tp)\n    binary_pyobj(object(), object())\n    unary_default()",
        "min_run_count": 2,
        "name": "bench_dispatch.NoPythonDispatch.time_dispatch_array_1d",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "05707650b7675868c56d7bfe435123521dd8d4229819c38286c2148266dcbcc6",
        "warmup_time": -1
    },
    "bench_dispatch.NoPythonDispatch.time_dispatch_array_3d": {
        "code": "class <locals>:\n    def timefunc(self, arg=samples[name]):\n        func = binary\n        for i in range(1000):\n            func(arg, arg)\n\ndef setup():\n    \"\"\"\n    Precompile jitted functions.  This will register many specializations\n    to choose from.\n    \"\"\"\n    from numba import jit\n    global binary, binary_pyobj, unary_default\n\n    @jit(nopython=True)\n    def binary(x, y):\n        pass\n\n    @jit(forceobj=True)\n    def binary_pyobj(x, y):\n        pass\n\n    @jit(nopython=True)\n    def unary_default(x=None):\n        pass\n\n    for tp in samples.values():\n        binary(tp, tp)\n    binary_pyobj(object(), object())\n    unary_default()",
        "min_run_count": 2,
        "name": "bench_dispatch.NoPythonDispatch.time_dispatch_array_3d",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "05707650b7675868c56d7bfe435123521dd8d4229819c38286c2148266dcbcc6",
        "warmup_time": -1
    },
    "bench_dispatch.NoPythonDispatch.time_dispatch_array_records": {
        "code": "class <locals>:\n    def timefunc(self, arg=samples[name]):\n        func = binary\n        for i in range(1000):\n            func(arg, arg)\n\ndef setup():\n    \"\"\"\n    Precompile jitted functions.  This will register many specializations\n    to choose from.\n    \"\"\"\n    from numba import jit\n    global binary, binary_pyobj, unary_default\n\n    @jit(nopython=True)\n    def binary(x, y):\n        pass\n\n    @jit(forceobj=True)\n    def binary_pyobj(x, y):\n        pass\n\n    @jit(nopython=True)\n    def unary_default(x=None):\n        pass\n\n    for tp in samples.values():\n        binary(tp, tp)\n    binary_pyobj(object(), object())\n    unary_default()",
        "min_run_count": 2,
        "name": "bench_dispatch.NoPythonDispatch.time_dispatch_array_records",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "05707650b7675868c56d7bfe435123521dd8d4229819c38286c2148266dcbcc6",
        "warmup_time": -1
    },
    "bench_dispatch.NoPythonDispatch.time_dispatch_bool": {
        "code": "class <locals>:\n    def timefunc(self, arg=samples[name]):\n        func = binary\n        for i in range(1000):\n            func(arg, arg)\n\ndef setup():\n    \"\"\"\n    Precompile jitted functions.  This will register many specializations\n    to choose from.\n    \"\"\"\n    from numba import jit\n    global binary, binary_pyobj, unary_default\n\n    @jit(nopython=True)\n    def binary(x, y):\n        pass\n\n    @jit(forceobj=True)\n    def binary_pyobj(x, y):\n        pass\n\n    @jit(nopython=True)\n    def unary_default(x=None):\n        pass\n\n    for tp in samples.values():\n        binary(tp, tp)\n    binary_pyobj(object(), object())\n    unary_default()",
        "min_run_count": 2,
        "name": "bench_dispatch.NoPythonDispatch.time_dispatch_bool",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "05707650b7675868c56d7bfe435123521dd8d4229819c38286c2148266dcbcc6",
        "warmup_time": -1
    },
    "bench_dispatch.NoPythonDispatch.time_dispatch_bytearray": {
        "code": "class <locals>:\n    def timefunc(self, arg=samples[name]):\n        func = binary\n        for i in range(1000):\n            func(arg, arg)\n\ndef setup():\n    \"\"\"\n    Precompile jitted functions.  This will register many specializations\n    to choose from.\n    \"\"\"\n    from numba import jit\n    global binary, binary_pyobj, unary_default\n\n    @jit(nopython=True)\n    def binary(x, y):\n        pass\n\n    @jit(forceobj=True)\n    def binary_pyobj(x, y):\n        pass\n\n    @jit(nopython=True)\n    def unary_default(x=None):\n        pass\n\n    for tp in samples.values():\n        binary(tp, tp)\n    binary_pyobj(object(), object())\n    unary_default()",
        "min_run_count": 2,
        "name": "bench_dispatch.NoPythonDispatch.time_dispatch_bytearray",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "05707650b7675868c56d7bfe435123521dd8d4229819c38286c2148266dcbcc6",
        "warmup_time": -1
    },
    "bench_dispatch.NoPythonDispatch.time_dispatch_complex": {
        "code": "class <locals>:\n    def timefunc(self, arg=samples[name]):\n        func = binary\n        for i in range(1000):\n            func(arg, arg)\n\ndef setup():\n    \"\"\"\n    Precompile jitted functions.  This will register many specializations\n    to choose from.\n    \"\"\"\n    from numba import jit\n    global binary, binary_pyobj, unary_default\n\n    @jit(nopython=True)\n    def binary(x, y):\n        pass\n\n    @jit(forceobj=True)\n    def binary_pyobj(x, y):\n        pass\n\n    @jit(nopython=True)\n    def unary_default(x=None):\n        pass\n\n    for tp in samples.values():\n        binary(tp, tp)\n    binary_pyobj(object(), object())\n    unary_default()",
        "min_run_count": 2,
        "name": "bench_dispatch.NoPythonDispatch.time_dispatch_complex",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "05707650b7675868c56d7bfe435123521dd8d4229819c38286c2148266dcbcc6",
        "warmup_time": -1
    },
    "bench_dispatch.NoPythonDispatch.time_dispatch_defaults": {
        "code": "class NoPythonDispatch:\n    def time_dispatch_defaults(self):\n        unary_default()\n\ndef setup():\n    \"\"\"\n    Precompile jitted functions.  This will register many specializations\n    to choose from.\n    \"\"\"\n    from numba import jit\n    global binary, binary_pyobj, unary_default\n\n    @jit(nopython=True)\n    def binary(x, y):\n        pass\n\n    @jit(forceobj=True)\n    def binary_pyobj(x, y):\n        pass\n\n    @jit(nopython=True)\n    def unary_default(x=None):\n        pass\n\n    for tp in samples.values():\n        binary(tp, tp)\n    binary_pyobj(object(), object())\n    unary_default()",
        "min_run_count": 2,
        "name": "bench_dispatch.NoPythonDispatch.time_dispatch_defaults",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "9fba0101c9f7c382cb5cbac32232e3548aaea428b652d55f266d6600c4207842",
        "warmup_time": -1
    },
    "bench_dispatch.NoPythonDispatch.time_dispatch_float": {
        "code": "class <locals>:\n    def timefunc(self, arg=samples[name]):\n        func = binary\n        for i in range(1000):\n            func(arg, arg)\n\ndef setup():\n    \"\"\"\n    Precompile jitted functions.  This will register many specializations\n    to choose from.\n    \"\"\"\n    from numba import jit\n    global binary, binary_pyobj, unary_default\n\n    @jit(nopython=True)\n    def binary(x, y):\n        pass\n\n    @jit(forceobj=True)\n    def binary_pyobj(x, y):\n        pass\n\n    @jit(nopython=True)\n    def unary_default(x=None):\n        pass\n\n    for tp in samples.values():\n        binary(tp, tp)\n    binary_pyobj(object(), object())\n    unary_default()",
        "min_run_count": 2,
        "name": "bench_dispatch.NoPythonDispatch.time_dispatch_float",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "05707650b7675868c56d7bfe435123521dd8d4229819c38286c2148266dcbcc6",
        "warmup_time": -1
    },
    "bench_dispatch.NoPythonDispatch.time_dispatch_int": {
        "code": "class <locals>:\n    def timefunc(self, arg=samples[name]):\n        func = binary\n        for i in range(1000):\n            func(arg, arg)\n\ndef setup():\n    \"\"\"\n    Precompile jitted functions.  This will register many specializations\n    to choose from.\n    \"\"\"\n    from numba import jit\n    global binary, binary_pyobj, unary_default\n\n    @jit(nopython=True)\n    def binary(x, y):\n        pass\n\n    @jit(forceobj=True)\n    def binary_pyobj(x, y):\n        pass\n\n    @jit(nopython=True)\n    def unary_default(x=None):\n        pass\n\n    for tp in samples.values():\n        binary(tp, tp)\n    binary_pyobj(object(), object())\n    unary_default()",
        "min_run_count": 2,
        "name": "bench_dispatch.NoPythonDispatch.time_dispatch_int",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "05707650b7675868c56d7bfe435123521dd8d4229819c38286c2148266dcbcc6",
        "warmup_time": -1
    },
    "bench_dispatch.NoPythonDispatch.time_dispatch_recarray": {
        "code": "class <locals>:\n    def timefunc(self, arg=samples[name]):\n        func = binary\n        for i in range(1000):\n            func(arg, arg)\n\ndef setup():\n    \"\"\"\n    Precompile jitted functions.  This will register many specializations\n    to choose from.\n    \"\"\"\n    from numba import jit\n    global binary, binary_pyobj, unary_default\n\n    @jit(nopython=True)\n    def binary(x, y):\n        pass\n\n    @jit(forceobj=True)\n    def binary_pyobj(x, y):\n        pass\n\n    @jit(nopython=True)\n    def unary_default(x=None):\n        pass\n\n    for tp in samples.values():\n        binary(tp, tp)\n    binary_pyobj(object(), object())\n    unary_default()",
        "min_run_count": 2,
        "name": "bench_dispatch.NoPythonDispatch.time_dispatch_recarray",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "05707650b7675868c56d7bfe435123521dd8d4229819c38286c2148266dcbcc6",
        "warmup_time": -1
    },
    "bench_dispatch.NoPythonDispatch.time_dispatch_record": {
        "code": "class <locals>:\n    def timefunc(self, arg=samples[name]):\n        func = binary\n        for i in range(1000):\n            func(arg, arg)\n\ndef setup():\n    \"\"\"\n    Precompile jitted functions.  This will register many specializations\n    to choose from.\n    \"\"\"\n    from numba import jit\n    global binary, binary_pyobj, unary_default\n\n    @jit(nopython=True)\n    def binary(x, y):\n        pass\n\n    @jit(forceobj=True)\n    def binary_pyobj(x, y):\n        pass\n\n    @jit(nopython=True)\n    def unary_default(x=None):\n        pass\n\n    for tp in samples.values():\n        binary(tp, tp)\n    binary_pyobj(object(), object())\n    unary_default()",
        "min_run_count": 2,
        "name": "bench_dispatch.NoPythonDispatch.time_dispatch_record",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "05707650b7675868c56d7bfe435123521dd8d4229819c38286c2148266dcbcc6",
        "warmup_time": -1
    },
    "bench_dispatch.NoPythonDispatch.time_dispatch_tuple": {
        "code": "class <locals>:\n    def timefunc(self, arg=samples[name]):\n        func = binary\n        for i in range(1000):\n            func(arg, arg)\n\ndef setup():\n    \"\"\"\n    Precompile jitted functions.  This will register many specializations\n    to choose from.\n    \"\"\"\n    from numba import jit\n    global binary, binary_pyobj, unary_default\n\n    @jit(nopython=True)\n    def binary(x, y):\n        pass\n\n    @jit(forceobj=True)\n    def binary_pyobj(x, y):\n        pass\n\n    @jit(nopython=True)\n    def unary_default(x=None):\n        pass\n\n    for tp in samples.values():\n        binary(tp, tp)\n    binary_pyobj(object(), object())\n    unary_default()",
        "min_run_count": 2,
        "name": "bench_dispatch.NoPythonDispatch.time_dispatch_tuple",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "05707650b7675868c56d7bfe435123521dd8d4229819c38286c2148266dcbcc6",
        "warmup_time": -1
    },
    "bench_dispatch.PyObjectDispatch.time_dispatch_pyobject": {
        "code": "class PyObjectDispatch:\n    def time_dispatch_pyobject(self):\n        x = object()\n        for i in range(1000):\n            binary_pyobj(x, x)\n\ndef setup():\n    \"\"\"\n    Precompile jitted functions.  This will register many specializations\n    to choose from.\n    \"\"\"\n    from numba import jit\n    global binary, binary_pyobj, unary_default\n\n    @jit(nopython=True)\n    def binary(x, y):\n        pass\n\n    @jit(forceobj=True)\n    def binary_pyobj(x, y):\n        pass\n\n    @jit(nopython=True)\n    def unary_default(x=None):\n        pass\n\n    for tp in samples.values():\n        binary(tp, tp)\n    binary_pyobj(object(), object())\n    unary_default()",
        "min_run_count": 2,
        "name": "bench_dispatch.PyObjectDispatch.time_dispatch_pyobject",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8ed3e0180ccac61c9469e83a2525e187d967a9478e9896941acb82d21a3adc72",
        "warmup_time": -1
    },
    "bench_gameoflife.GameOfLife.time_gameoflife": {
        "code": "class GameOfLife:\n    def time_gameoflife(self):\n        run_game(10)\n\ndef setup():\n    \"\"\"\n    Precompile jitted functions.\n    \"\"\"\n\n    from numba import jit\n\n    global wrap, increment_neighbors, numba_life_step\n\n\n    @jit(nopython=True)\n    def wrap(k, max_k):\n        if k == -1:\n            return max_k - 1\n        elif k == max_k:\n            return 0\n        else:\n            return k\n\n    @jit(nopython=True)\n    def increment_neighbors(i, j, neighbors):\n        ni, nj = neighbors.shape\n        for delta_i in (-1, 0, 1):\n            neighbor_i = wrap(i + delta_i, ni)\n            for delta_j in (-1, 0, 1):\n                if delta_i != 0 or delta_j != 0:\n                    neighbor_j = wrap(j + delta_j, nj)\n                    neighbors[neighbor_i, neighbor_j] += 1\n\n    @jit\n    def numba_life_step(X):\n        # Compute # of live neighbours per cell\n        neighbors = np.zeros_like(X, dtype=np.int8)\n        for i in range(X.shape[0]):\n            for j in range(X.shape[1]):\n                if X[i,j]:\n                    increment_neighbors(i, j, neighbors)\n        # Return next iteration of the game state\n        return (neighbors == 3) | (X & (neighbors == 2))\n\n    run_game(10)",
        "min_run_count": 2,
        "name": "bench_gameoflife.GameOfLife.time_gameoflife",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "3a62cd617bff882688bdb0a603333b98170f24fc0fc77ea3f6d653aac46a72ee",
        "warmup_time": -1
    },
    "bench_ising.IsingModel.time_ising": {
        "code": "class IsingModel:\n    def time_ising(self):\n        x = x_start.copy()\n        for i in range(N_iterations):\n            update(x)\n\ndef setup():\n\n    from numba import jit\n\n    global _update, update\n\n    @jit(nopython=True)\n    def _update(x, i, j):\n        n, m = x.shape\n        dE = 2* x[i, j] * (\n                        x[(i-1)%n, (j-1)%m]\n                    + x[(i-1)%n,  j     ]\n                    + x[(i-1)%n, (j+1)%m]\n\n                    + x[ i     , (j-1)%m]\n                    + x[ i     , (j+1)%m]\n\n                    + x[(i+1)%n, (j-1)%m]\n                    + x[(i+1)%n,  j     ]\n                    + x[(i+1)%n, (j+1)%m]\n                    )\n        if dE <= 0 or exp(-dE / kT) > np.random.random():\n            x[i, j] *= -1\n\n    @jit(nopython=True)\n    def update(x):\n        n, m = x.shape\n\n        for i in range(n):\n            for j in range(0, m, 2):  # Even columns first to avoid overlap\n                _update(x, j, i)\n\n        for i in range(n):\n            for j in range(1, m, 2):  # Odd columns second to avoid overlap\n                _update(x, j, i)",
        "min_run_count": 2,
        "name": "bench_ising.IsingModel.time_ising",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "72f6ae6e633558ee6af5118f6c3877e5b6979722eff230e381df38fcdb06be87",
        "warmup_time": -1
    },
    "bench_iterating.MonoArrayIterators.time_array_iter_1d": {
        "code": "class MonoArrayIterators:\n    def time_array_iter_1d(self):\n        array_iter_1d(arr1)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MonoArrayIterators.time_array_iter_1d",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "57da53fe053d58fe885e45316cb6d7cacb759ae3a2ab7bff6fc60a3872f50ae5",
        "warmup_time": -1
    },
    "bench_iterating.MonoArrayIterators.time_flat_index_1d": {
        "code": "class MonoArrayIterators:\n    def time_flat_index_1d(self):\n        flat_index(arr1)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MonoArrayIterators.time_flat_index_1d",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b7f1d3a1d70fb1e55addabda8a1b9c7b7b38728f8ad1c84290eae97e394c1a8a",
        "warmup_time": -1
    },
    "bench_iterating.MonoArrayIterators.time_flat_index_2d_C": {
        "code": "class MonoArrayIterators:\n    def time_flat_index_2d_C(self):\n        flat_index(arr2c)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MonoArrayIterators.time_flat_index_2d_C",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "54bf4a92f4608ef149d73c7bb8ebdc927ef4c5aaa5bc54bc6bf52c44cec7c734",
        "warmup_time": -1
    },
    "bench_iterating.MonoArrayIterators.time_flat_index_2d_fortran": {
        "code": "class MonoArrayIterators:\n    def time_flat_index_2d_fortran(self):\n        flat_index(arr2f)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MonoArrayIterators.time_flat_index_2d_fortran",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "5e91cfec080ae7169f5c9ee5c35f728e43d56c1b8aa65fe6698200c4199a0e09",
        "warmup_time": -1
    },
    "bench_iterating.MonoArrayIterators.time_flat_index_2d_non_contiguous": {
        "code": "class MonoArrayIterators:\n    def time_flat_index_2d_non_contiguous(self):\n        flat_index(arr2a)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MonoArrayIterators.time_flat_index_2d_non_contiguous",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "2cf244735c42fe17473d3c82052219e4f46a79fe4258363be73771f73245378f",
        "warmup_time": -1
    },
    "bench_iterating.MonoArrayIterators.time_flat_iter_1d": {
        "code": "class MonoArrayIterators:\n    def time_flat_iter_1d(self):\n        flat_iter(arr1)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MonoArrayIterators.time_flat_iter_1d",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8337e998541e2b10c16e119da431671bcd4804e27c6f54b41a8c4f232db83bf7",
        "warmup_time": -1
    },
    "bench_iterating.MonoArrayIterators.time_flat_iter_2d_C": {
        "code": "class MonoArrayIterators:\n    def time_flat_iter_2d_C(self):\n        flat_iter(arr2c)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MonoArrayIterators.time_flat_iter_2d_C",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "06e96407434bd4f3fd579dc94a6fd87187327702b9d4809b2b15cba0cbeeeb38",
        "warmup_time": -1
    },
    "bench_iterating.MonoArrayIterators.time_flat_iter_2d_fortran": {
        "code": "class MonoArrayIterators:\n    def time_flat_iter_2d_fortran(self):\n        flat_iter(arr2f)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MonoArrayIterators.time_flat_iter_2d_fortran",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "38ac6b00833d808327fc6d569f3ac3adab20c02afa5cd4619221e014524e382e",
        "warmup_time": -1
    },
    "bench_iterating.MonoArrayIterators.time_flat_iter_2d_non_contiguous": {
        "code": "class MonoArrayIterators:\n    def time_flat_iter_2d_non_contiguous(self):\n        flat_iter(arr2a)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MonoArrayIterators.time_flat_iter_2d_non_contiguous",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7c602cc257568b80d8d1f65f1548b5d2681839adbc8847a83d1150a839ec44a5",
        "warmup_time": -1
    },
    "bench_iterating.MonoArrayIterators.time_ndindex_1d": {
        "code": "class MonoArrayIterators:\n    def time_ndindex_1d(self):\n        ndindex(arr1)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MonoArrayIterators.time_ndindex_1d",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b2ae77fc8cd6358c0dfc04beec2e3c8d022b0e1b9902a321ca2c079935611569",
        "warmup_time": -1
    },
    "bench_iterating.MonoArrayIterators.time_ndindex_2d": {
        "code": "class MonoArrayIterators:\n    def time_ndindex_2d(self):\n        ndindex(arr2c)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MonoArrayIterators.time_ndindex_2d",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d9b8205974d4155aee3e3805ae90cdfd23d4b04a32dd159d3cba73e35e2cb7b9",
        "warmup_time": -1
    },
    "bench_iterating.MonoArrayIterators.time_nditer_iter_1d": {
        "code": "class MonoArrayIterators:\n    def time_nditer_iter_1d(self):\n        nditer1(arr1)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MonoArrayIterators.time_nditer_iter_1d",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "259812336d8205b39158019bb9319313d854044173fb3526d6323e4ebb8ed1ba",
        "warmup_time": -1
    },
    "bench_iterating.MonoArrayIterators.time_nditer_iter_2d_C": {
        "code": "class MonoArrayIterators:\n    def time_nditer_iter_2d_C(self):\n        nditer1(arr2c)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MonoArrayIterators.time_nditer_iter_2d_C",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d65c58298e884c062baa6dd8e43e5ad3a9e1549d734b653b45bc0de93bf5bf4b",
        "warmup_time": -1
    },
    "bench_iterating.MonoArrayIterators.time_nditer_iter_2d_C_small_inner_dim": {
        "code": "class MonoArrayIterators:\n    def time_nditer_iter_2d_C_small_inner_dim(self):\n        nditer1(arr2c2)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MonoArrayIterators.time_nditer_iter_2d_C_small_inner_dim",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "dd15d3f06446b7d69d6837ec3c86f48997f0ff7223aea7bb7c17178dfdd4e5e9",
        "warmup_time": -1
    },
    "bench_iterating.MonoArrayIterators.time_nditer_iter_2d_fortran": {
        "code": "class MonoArrayIterators:\n    def time_nditer_iter_2d_fortran(self):\n        nditer1(arr2f)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MonoArrayIterators.time_nditer_iter_2d_fortran",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "0c1fb4d1bf42c972132d876a3d5acdcb2494c11cb8b02db86a9011b2704ba215",
        "warmup_time": -1
    },
    "bench_iterating.MonoArrayIterators.time_nditer_iter_2d_non_contiguous": {
        "code": "class MonoArrayIterators:\n    def time_nditer_iter_2d_non_contiguous(self):\n        nditer1(arr2a)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MonoArrayIterators.time_nditer_iter_2d_non_contiguous",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "e57997336e771943463fa9dc52ef16b2ced0f6e5f4bb0af605af451dd6c0775d",
        "warmup_time": -1
    },
    "bench_iterating.MonoArrayIterators.time_range_index_1d": {
        "code": "class MonoArrayIterators:\n    def time_range_index_1d(self):\n        range1d(arr1)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MonoArrayIterators.time_range_index_1d",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "cc998099978a81bbc27d9a2dfc00a512f2b4de24babcdb8ea45d90ceb1a0fde9",
        "warmup_time": -1
    },
    "bench_iterating.MonoArrayIterators.time_range_index_2d": {
        "code": "class MonoArrayIterators:\n    def time_range_index_2d(self):\n        range2d(arr2c)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MonoArrayIterators.time_range_index_2d",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8a5c201eeec20d2e6c7b2f3ca84c04ec65cf2136684c9938e3ceadb860e4e37d",
        "warmup_time": -1
    },
    "bench_iterating.MultiArrayIterators.time_nditer_three_2d_A_A_A": {
        "code": "class MultiArrayIterators:\n    def time_nditer_three_2d_A_A_A(self):\n        nditer3(arr2a, arr2a, arr2a)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MultiArrayIterators.time_nditer_three_2d_A_A_A",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "500acd1a2bf9004f8fdd1bbc4b1653e0d0923cdd9af6e838b6d19121e5ff036c",
        "warmup_time": -1
    },
    "bench_iterating.MultiArrayIterators.time_nditer_three_2d_C_C_C": {
        "code": "class MultiArrayIterators:\n    def time_nditer_three_2d_C_C_C(self):\n        nditer3(arr2c, arr2c, arr2c)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MultiArrayIterators.time_nditer_three_2d_C_C_C",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b64fb51f315fb643a50ba15dcaac8a8e56036a75d7a497f9b6bd785a60791456",
        "warmup_time": -1
    },
    "bench_iterating.MultiArrayIterators.time_nditer_three_2d_F_F_F": {
        "code": "class MultiArrayIterators:\n    def time_nditer_three_2d_F_F_F(self):\n        nditer3(arr2f, arr2f, arr2f)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MultiArrayIterators.time_nditer_three_2d_F_F_F",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d3f6b711e8406cc33c4c2daf83e0e05a14bfc6a26f9de88a0adc3e2800d3f4ec",
        "warmup_time": -1
    },
    "bench_iterating.MultiArrayIterators.time_nditer_two_1d": {
        "code": "class MultiArrayIterators:\n    def time_nditer_two_1d(self):\n        nditer2(arr1, arr1)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MultiArrayIterators.time_nditer_two_1d",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "0db3b960fd73f966b3dc771c16a684e00f5d82c7bf00e25bb87d0c67bb6cdb8f",
        "warmup_time": -1
    },
    "bench_iterating.MultiArrayIterators.time_nditer_two_2d_A_A": {
        "code": "class MultiArrayIterators:\n    def time_nditer_two_2d_A_A(self):\n        nditer2(arr2a, arr2a)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MultiArrayIterators.time_nditer_two_2d_A_A",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8a9132f23bf7d3342050e1c0ef971f789e62fb475b8771a4b92a2aa1341f4aca",
        "warmup_time": -1
    },
    "bench_iterating.MultiArrayIterators.time_nditer_two_2d_C_A": {
        "code": "class MultiArrayIterators:\n    def time_nditer_two_2d_C_A(self):\n        nditer2(arr2c, arr2a)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MultiArrayIterators.time_nditer_two_2d_C_A",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "96d5cd0cc60500faa10579ea02cb6fc65b877d47e6be6e2430040064081b190a",
        "warmup_time": -1
    },
    "bench_iterating.MultiArrayIterators.time_nditer_two_2d_C_A_small_inner_dim": {
        "code": "class MultiArrayIterators:\n    def time_nditer_two_2d_C_A_small_inner_dim(self):\n        nditer2(arr2c2, arr2a2)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MultiArrayIterators.time_nditer_two_2d_C_A_small_inner_dim",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "01af8198dd1889e45c57b1b57f276240c40e737a3e8f729ff499bda7735a3772",
        "warmup_time": -1
    },
    "bench_iterating.MultiArrayIterators.time_nditer_two_2d_C_C": {
        "code": "class MultiArrayIterators:\n    def time_nditer_two_2d_C_C(self):\n        nditer2(arr2c, arr2c)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MultiArrayIterators.time_nditer_two_2d_C_C",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "32641ad7bb229f55e4241e740d0176addf1fd1df283690649a9cd5d27965f465",
        "warmup_time": -1
    },
    "bench_iterating.MultiArrayIterators.time_nditer_two_2d_C_C_small_inner_dim": {
        "code": "class MultiArrayIterators:\n    def time_nditer_two_2d_C_C_small_inner_dim(self):\n        nditer2(arr2c2, arr2c2)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MultiArrayIterators.time_nditer_two_2d_C_C_small_inner_dim",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "c90b2f273702b28d0312124e6a50d5e6a7f5c3c39abe3bb6caf980983f62ac97",
        "warmup_time": -1
    },
    "bench_iterating.MultiArrayIterators.time_nditer_two_2d_F_C": {
        "code": "class MultiArrayIterators:\n    def time_nditer_two_2d_F_C(self):\n        nditer2(arr2f, arr2c)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MultiArrayIterators.time_nditer_two_2d_F_C",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "2a6cbd3a3d226079ccf5bdab974477fd4545f001290ff8d81a3d33644f77c418",
        "warmup_time": -1
    },
    "bench_iterating.MultiArrayIterators.time_nditer_two_2d_F_C_small_inner_dim": {
        "code": "class MultiArrayIterators:\n    def time_nditer_two_2d_F_C_small_inner_dim(self):\n        nditer2(arr2f2, arr2c2)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MultiArrayIterators.time_nditer_two_2d_F_C_small_inner_dim",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "66ddef4117fa4a5d309043ff39c0305c9acbf2ffaa57549096cc0e28cd286ff3",
        "warmup_time": -1
    },
    "bench_iterating.MultiArrayIterators.time_nditer_two_2d_F_F": {
        "code": "class MultiArrayIterators:\n    def time_nditer_two_2d_F_F(self):\n        nditer2(arr2f, arr2f)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MultiArrayIterators.time_nditer_two_2d_F_F",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "38a118ff40e72c337261400c611aaa3af7fdd15b1ed0089c2b8a3ee439e59873",
        "warmup_time": -1
    },
    "bench_iterating.MultiArrayIterators.time_nditer_two_2d_F_F_small_inner_dim": {
        "code": "class MultiArrayIterators:\n    def time_nditer_two_2d_F_F_small_inner_dim(self):\n        nditer2(arr2f2, arr2f2)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MultiArrayIterators.time_nditer_two_2d_F_F_small_inner_dim",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "9568435aff383beae902fa954118cad34628e2606e91f7b2df6e56f66538acc6",
        "warmup_time": -1
    },
    "bench_iterating.MultiArrayIterators.time_zip_flat_two_1d": {
        "code": "class MultiArrayIterators:\n    def time_zip_flat_two_1d(self):\n        zip_flat(arr1, arr1)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MultiArrayIterators.time_zip_flat_two_1d",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "5ad5436ab7daa9365d272659a23a717617f544890049cf97cf78804086ccd56c",
        "warmup_time": -1
    },
    "bench_iterating.MultiArrayIterators.time_zip_flat_two_2d_A_A": {
        "code": "class MultiArrayIterators:\n    def time_zip_flat_two_2d_A_A(self):\n        zip_flat(arr2a, arr2a)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MultiArrayIterators.time_zip_flat_two_2d_A_A",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "3073d1a41dbb236c2b40b58d5438b0c0b98dd5325627dcea3f14f078ed14d630",
        "warmup_time": -1
    },
    "bench_iterating.MultiArrayIterators.time_zip_flat_two_2d_C_C": {
        "code": "class MultiArrayIterators:\n    def time_zip_flat_two_2d_C_C(self):\n        zip_flat(arr2c, arr2c)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MultiArrayIterators.time_zip_flat_two_2d_C_C",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7a868ddea995431da1f84d5686b1871019ba27bde1091b16b78b42cb820ed852",
        "warmup_time": -1
    },
    "bench_iterating.MultiArrayIterators.time_zip_flat_two_2d_C_C_small_inner_dim": {
        "code": "class MultiArrayIterators:\n    def time_zip_flat_two_2d_C_C_small_inner_dim(self):\n        zip_flat(arr2c2, arr2c2)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MultiArrayIterators.time_zip_flat_two_2d_C_C_small_inner_dim",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "9e071fa202331aee5a78b25f55f2522a1976f22c552fb0eb3d61ab153c5ea7c2",
        "warmup_time": -1
    },
    "bench_iterating.MultiArrayIterators.time_zip_flat_two_2d_F_F": {
        "code": "class MultiArrayIterators:\n    def time_zip_flat_two_2d_F_F(self):\n        zip_flat(arr2f, arr2f)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MultiArrayIterators.time_zip_flat_two_2d_F_F",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f4b6a2bcd6789acd6256e9e999566be64e5b4ecc960b658626a1732cb7a76d3e",
        "warmup_time": -1
    },
    "bench_iterating.MultiArrayIterators.time_zip_iter_two_1d": {
        "code": "class MultiArrayIterators:\n    def time_zip_iter_two_1d(self):\n        zip_iter(arr1, arr1)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def array_iter_1d(arr):\n        total = zero\n        for val in arr:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_iter(arr):\n        total = zero\n        for val in arr.flat:\n            total += val\n        return total\n\n    @jit(nopython=True)\n    def flat_index(arr):\n        total = zero\n        flat = arr.flat\n        for i in range(arr.size):\n            total += flat[i]\n        return total\n\n    @jit(nopython=True)\n    def ndindex(arr):\n        total = zero\n        for ind in np.ndindex(arr.shape):\n            total += arr[ind]\n        return total\n\n    @jit(nopython=True)\n    def range1d(arr):\n        total = zero\n        n, = arr.shape\n        for i in range(n):\n            total += arr[i]\n        return total\n\n    @jit(nopython=True)\n    def range2d(arr):\n        total = zero\n        m, n = arr.shape\n        for i in range(m):\n            for j in range(n):\n                total += arr[i, j]\n        return total\n\n    @jit(nopython=True)\n    def nditer1(a):\n        total = zero\n        for u in np.nditer(a):\n            total += u.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer2(a, b):\n        total = zero\n        for u, v in np.nditer((a, b)):\n            total += u.item() * v.item()\n        return total\n\n    @jit(nopython=True)\n    def nditer3(a, b, out):\n        total = zero\n        for u, v, res in np.nditer((a, b, out)):\n            res.itemset(u.item() * v.item())\n        return total\n\n    @jit(nopython=True)\n    def zip_iter(a, b):\n        total = zero\n        for u, v in zip(a, b):\n            total += u * v\n        return total\n\n    @jit(nopython=True)\n    def zip_flat(a, b):\n        total = zero\n        for u, v in zip(a.flat, b.flat):\n            total += u * v\n        return total\n\n    globals().update(locals())",
        "min_run_count": 2,
        "name": "bench_iterating.MultiArrayIterators.time_zip_iter_two_1d",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "93bb77ccc5fe86a4494de9bc6852bdeaafb572d9beb4868b016bcdd04e7107da",
        "warmup_time": -1
    },
    "bench_jitclass.JitClassDispatch.time_constructor_call": {
        "code": "class <locals>:\n    def f(self):\n        globals()[fn](self.N)\n\ndef setup():\n    from numba import njit, jitclass, uint32\n\n    @jitclass([('val', uint32)])\n    class Box:\n        def __init__(self, val):\n            self.val = val\n\n        def inc(self):\n            self.val += 1\n\n        @property\n        def value(self):\n            return self.val\n\n        @value.setter\n        def value(self, new_value):\n            self.val = new_value\n\n    @njit\n    def method_call(N):\n        b = Box(0)\n        for i in range(N):\n            b.inc()\n        return b\n\n    @njit\n    def property_access(N):\n        acc = 0\n        b = Box(10)\n        for i in range(N):\n            acc += b.value\n\n        return acc\n\n    @njit\n    def property_setting(N):\n        b = Box(0)\n        for i in range(N):\n            b.value = i\n\n        return b\n\n    @njit\n    def constructor_call(N):\n        l = []\n        for i in range(N):\n            l.append(Box(i))\n\n        return l\n\n    globals().update(locals())\n\nclass JitClassDispatch:\n    def setup(self):\n        for fn in self.funcs:\n            globals()[fn](1)",
        "min_run_count": 2,
        "name": "bench_jitclass.JitClassDispatch.time_constructor_call",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "3b61ca05157c53fe2209b69c2763350f7bd0dc94fea8e13e6c5f3ae8d8903e42",
        "warmup_time": -1
    },
    "bench_jitclass.JitClassDispatch.time_method_call": {
        "code": "class <locals>:\n    def f(self):\n        globals()[fn](self.N)\n\ndef setup():\n    from numba import njit, jitclass, uint32\n\n    @jitclass([('val', uint32)])\n    class Box:\n        def __init__(self, val):\n            self.val = val\n\n        def inc(self):\n            self.val += 1\n\n        @property\n        def value(self):\n            return self.val\n\n        @value.setter\n        def value(self, new_value):\n            self.val = new_value\n\n    @njit\n    def method_call(N):\n        b = Box(0)\n        for i in range(N):\n            b.inc()\n        return b\n\n    @njit\n    def property_access(N):\n        acc = 0\n        b = Box(10)\n        for i in range(N):\n            acc += b.value\n\n        return acc\n\n    @njit\n    def property_setting(N):\n        b = Box(0)\n        for i in range(N):\n            b.value = i\n\n        return b\n\n    @njit\n    def constructor_call(N):\n        l = []\n        for i in range(N):\n            l.append(Box(i))\n\n        return l\n\n    globals().update(locals())\n\nclass JitClassDispatch:\n    def setup(self):\n        for fn in self.funcs:\n            globals()[fn](1)",
        "min_run_count": 2,
        "name": "bench_jitclass.JitClassDispatch.time_method_call",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "3b61ca05157c53fe2209b69c2763350f7bd0dc94fea8e13e6c5f3ae8d8903e42",
        "warmup_time": -1
    },
    "bench_jitclass.JitClassDispatch.time_property_access": {
        "code": "class <locals>:\n    def f(self):\n        globals()[fn](self.N)\n\ndef setup():\n    from numba import njit, jitclass, uint32\n\n    @jitclass([('val', uint32)])\n    class Box:\n        def __init__(self, val):\n            self.val = val\n\n        def inc(self):\n            self.val += 1\n\n        @property\n        def value(self):\n            return self.val\n\n        @value.setter\n        def value(self, new_value):\n            self.val = new_value\n\n    @njit\n    def method_call(N):\n        b = Box(0)\n        for i in range(N):\n            b.inc()\n        return b\n\n    @njit\n    def property_access(N):\n        acc = 0\n        b = Box(10)\n        for i in range(N):\n            acc += b.value\n\n        return acc\n\n    @njit\n    def property_setting(N):\n        b = Box(0)\n        for i in range(N):\n            b.value = i\n\n        return b\n\n    @njit\n    def constructor_call(N):\n        l = []\n        for i in range(N):\n            l.append(Box(i))\n\n        return l\n\n    globals().update(locals())\n\nclass JitClassDispatch:\n    def setup(self):\n        for fn in self.funcs:\n            globals()[fn](1)",
        "min_run_count": 2,
        "name": "bench_jitclass.JitClassDispatch.time_property_access",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "3b61ca05157c53fe2209b69c2763350f7bd0dc94fea8e13e6c5f3ae8d8903e42",
        "warmup_time": -1
    },
    "bench_jitclass.JitClassDispatch.time_property_setting": {
        "code": "class <locals>:\n    def f(self):\n        globals()[fn](self.N)\n\ndef setup():\n    from numba import njit, jitclass, uint32\n\n    @jitclass([('val', uint32)])\n    class Box:\n        def __init__(self, val):\n            self.val = val\n\n        def inc(self):\n            self.val += 1\n\n        @property\n        def value(self):\n            return self.val\n\n        @value.setter\n        def value(self, new_value):\n            self.val = new_value\n\n    @njit\n    def method_call(N):\n        b = Box(0)\n        for i in range(N):\n            b.inc()\n        return b\n\n    @njit\n    def property_access(N):\n        acc = 0\n        b = Box(10)\n        for i in range(N):\n            acc += b.value\n\n        return acc\n\n    @njit\n    def property_setting(N):\n        b = Box(0)\n        for i in range(N):\n            b.value = i\n\n        return b\n\n    @njit\n    def constructor_call(N):\n        l = []\n        for i in range(N):\n            l.append(Box(i))\n\n        return l\n\n    globals().update(locals())\n\nclass JitClassDispatch:\n    def setup(self):\n        for fn in self.funcs:\n            globals()[fn](1)",
        "min_run_count": 2,
        "name": "bench_jitclass.JitClassDispatch.time_property_setting",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "3b61ca05157c53fe2209b69c2763350f7bd0dc94fea8e13e6c5f3ae8d8903e42",
        "warmup_time": -1
    },
    "bench_laplace.Laplace.time_laplace": {
        "code": "class Laplace:\n    def time_laplace(self):\n        self.run_laplace(self.N, self.Niter)\n\ndef setup():\n    from numba import jit\n\n    global laplace\n\n    @jit(nopython=True)\n    def laplace(N, Niter):\n        u = np.zeros((N, N))\n        u[0] = 1\n        for i in range(Niter):\n            u[1:(-1), 1:(-1)] = ((((u[2:, 1:(-1)] + u[:(-2), 1:(-1)]) * dy2) +\n                                ((u[1:(-1), 2:] + u[1:(-1), :(-2)]) * dx2))\n                                / (2 * (dx2 + dy2)))\n        return u\n\nclass Laplace:\n    def setup(self):\n        # Warm up\n        self.run_laplace(10, 10)",
        "min_run_count": 2,
        "name": "bench_laplace.Laplace.time_laplace",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1c3e45673c275288aa44b7f493d4e5a82cc91cc7ac51da06b3c2cb49bd972c06",
        "warmup_time": -1
    },
    "bench_lists.ListConstruction.time_list_append": {
        "code": "class ListConstruction:\n    def time_list_append(self):\n        list_append(self.n, 0)\n\ndef setup():\n    from numba import jit\n\n    @jit(nopython=True)\n    def list_append(n, i):\n        l = []\n        for v in range(n):\n            l.append(v)\n        return l[i]\n\n    @jit(nopython=True)\n    def list_extend(n, i):\n        l = []\n        l.extend(range(n // 2))\n        l.extend(range(n // 2))\n        return l[i]\n\n    @jit(nopython=True)\n    def list_call(n, i):\n        l = list(range(n))\n        return l[i]\n\n\n    @jit(nopython=True)\n    def list_return(n):\n        return [0] * n\n\n    @jit(nopython=True)\n    def list_pop(n):\n        l = list(range(n))\n        v = 0\n        while len(l) > 0:\n            v = v ^ l.pop()\n        return v\n\n    @jit(nopython=True)\n    def list_insert(n, i):\n        l = [0]\n        for v in range(n):\n            l.insert(0, v)\n        return l[i]\n\n    globals().update(locals())\n\nclass ListConstruction:\n    def setup(self):\n        # Warm up\n        list_append(1, 0)\n        list_extend(1, 0)\n        list_call(1, 0)",
        "min_run_count": 2,
        "name": "bench_lists.ListConstruction.time_list_append",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "81d1e85460ae03989565b3a1efdeefa7d1e2a722e896c0b2769a51fa4bf40c0c",
        "warmup_time": -1
    },
    "bench_lists.ListConstruction.time_list_call": {
        "code": "class ListConstruction:\n    def time_list_call(self):\n        list_call(self.n, 0)\n\ndef setup():\n    from numba import jit\n\n    @jit(nopython=True)\n    def list_append(n, i):\n        l = []\n        for v in range(n):\n            l.append(v)\n        return l[i]\n\n    @jit(nopython=True)\n    def list_extend(n, i):\n        l = []\n        l.extend(range(n // 2))\n        l.extend(range(n // 2))\n        return l[i]\n\n    @jit(nopython=True)\n    def list_call(n, i):\n        l = list(range(n))\n        return l[i]\n\n\n    @jit(nopython=True)\n    def list_return(n):\n        return [0] * n\n\n    @jit(nopython=True)\n    def list_pop(n):\n        l = list(range(n))\n        v = 0\n        while len(l) > 0:\n            v = v ^ l.pop()\n        return v\n\n    @jit(nopython=True)\n    def list_insert(n, i):\n        l = [0]\n        for v in range(n):\n            l.insert(0, v)\n        return l[i]\n\n    globals().update(locals())\n\nclass ListConstruction:\n    def setup(self):\n        # Warm up\n        list_append(1, 0)\n        list_extend(1, 0)\n        list_call(1, 0)",
        "min_run_count": 2,
        "name": "bench_lists.ListConstruction.time_list_call",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "41b04d1cb2f5f74679d1dec5b320f33ebce22e06b9969b2d36f8ed6fc89bcd25",
        "warmup_time": -1
    },
    "bench_lists.ListConstruction.time_list_extend": {
        "code": "class ListConstruction:\n    def time_list_extend(self):\n        list_extend(self.n, 0)\n\ndef setup():\n    from numba import jit\n\n    @jit(nopython=True)\n    def list_append(n, i):\n        l = []\n        for v in range(n):\n            l.append(v)\n        return l[i]\n\n    @jit(nopython=True)\n    def list_extend(n, i):\n        l = []\n        l.extend(range(n // 2))\n        l.extend(range(n // 2))\n        return l[i]\n\n    @jit(nopython=True)\n    def list_call(n, i):\n        l = list(range(n))\n        return l[i]\n\n\n    @jit(nopython=True)\n    def list_return(n):\n        return [0] * n\n\n    @jit(nopython=True)\n    def list_pop(n):\n        l = list(range(n))\n        v = 0\n        while len(l) > 0:\n            v = v ^ l.pop()\n        return v\n\n    @jit(nopython=True)\n    def list_insert(n, i):\n        l = [0]\n        for v in range(n):\n            l.insert(0, v)\n        return l[i]\n\n    globals().update(locals())\n\nclass ListConstruction:\n    def setup(self):\n        # Warm up\n        list_append(1, 0)\n        list_extend(1, 0)\n        list_call(1, 0)",
        "min_run_count": 2,
        "name": "bench_lists.ListConstruction.time_list_extend",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "0cc0f1deb7209a8752f2f939afdd2542486552bddb23b7b3407e7f7c23ea6128",
        "warmup_time": -1
    },
    "bench_lists.ListMutation.time_list_insert": {
        "code": "class ListMutation:\n    def time_list_insert(self):\n        # list.insert() is quadratic, so reduce the effort\n        list_insert(self.n // 10, 0)\n\ndef setup():\n    from numba import jit\n\n    @jit(nopython=True)\n    def list_append(n, i):\n        l = []\n        for v in range(n):\n            l.append(v)\n        return l[i]\n\n    @jit(nopython=True)\n    def list_extend(n, i):\n        l = []\n        l.extend(range(n // 2))\n        l.extend(range(n // 2))\n        return l[i]\n\n    @jit(nopython=True)\n    def list_call(n, i):\n        l = list(range(n))\n        return l[i]\n\n\n    @jit(nopython=True)\n    def list_return(n):\n        return [0] * n\n\n    @jit(nopython=True)\n    def list_pop(n):\n        l = list(range(n))\n        v = 0\n        while len(l) > 0:\n            v = v ^ l.pop()\n        return v\n\n    @jit(nopython=True)\n    def list_insert(n, i):\n        l = [0]\n        for v in range(n):\n            l.insert(0, v)\n        return l[i]\n\n    globals().update(locals())\n\nclass ListMutation:\n    def setup(self):\n        # Warm up\n        list_pop(1)\n        list_insert(1, 0)",
        "min_run_count": 2,
        "name": "bench_lists.ListMutation.time_list_insert",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "63ce87c4b4a71a10593c6bc5b3ef7b531fc14d57313c35c8634feecb795826d9",
        "warmup_time": -1
    },
    "bench_lists.ListMutation.time_list_pop": {
        "code": "class ListMutation:\n    def time_list_pop(self):\n        list_pop(self.n)\n\ndef setup():\n    from numba import jit\n\n    @jit(nopython=True)\n    def list_append(n, i):\n        l = []\n        for v in range(n):\n            l.append(v)\n        return l[i]\n\n    @jit(nopython=True)\n    def list_extend(n, i):\n        l = []\n        l.extend(range(n // 2))\n        l.extend(range(n // 2))\n        return l[i]\n\n    @jit(nopython=True)\n    def list_call(n, i):\n        l = list(range(n))\n        return l[i]\n\n\n    @jit(nopython=True)\n    def list_return(n):\n        return [0] * n\n\n    @jit(nopython=True)\n    def list_pop(n):\n        l = list(range(n))\n        v = 0\n        while len(l) > 0:\n            v = v ^ l.pop()\n        return v\n\n    @jit(nopython=True)\n    def list_insert(n, i):\n        l = [0]\n        for v in range(n):\n            l.insert(0, v)\n        return l[i]\n\n    globals().update(locals())\n\nclass ListMutation:\n    def setup(self):\n        # Warm up\n        list_pop(1)\n        list_insert(1, 0)",
        "min_run_count": 2,
        "name": "bench_lists.ListMutation.time_list_pop",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "9c7c06605e394adeda4f053accb71ec123fb5ac0f5abfa3d991094203f7f4ff4",
        "warmup_time": -1
    },
    "bench_lists.ListReturn.time_list_return": {
        "code": "class ListReturn:\n    def time_list_return(self):\n        list_return(self.n)\n\ndef setup():\n    from numba import jit\n\n    @jit(nopython=True)\n    def list_append(n, i):\n        l = []\n        for v in range(n):\n            l.append(v)\n        return l[i]\n\n    @jit(nopython=True)\n    def list_extend(n, i):\n        l = []\n        l.extend(range(n // 2))\n        l.extend(range(n // 2))\n        return l[i]\n\n    @jit(nopython=True)\n    def list_call(n, i):\n        l = list(range(n))\n        return l[i]\n\n\n    @jit(nopython=True)\n    def list_return(n):\n        return [0] * n\n\n    @jit(nopython=True)\n    def list_pop(n):\n        l = list(range(n))\n        v = 0\n        while len(l) > 0:\n            v = v ^ l.pop()\n        return v\n\n    @jit(nopython=True)\n    def list_insert(n, i):\n        l = [0]\n        for v in range(n):\n            l.insert(0, v)\n        return l[i]\n\n    globals().update(locals())\n\nclass ListReturn:\n    def setup(self):\n        # Warm up\n        list_return(1)",
        "min_run_count": 2,
        "name": "bench_lists.ListReturn.time_list_return",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8f0521aa8ff4ee06f39b72cea9dc63bd6d51ad2ad0aa8a67e738f8a16b427069",
        "warmup_time": -1
    },
    "bench_misc.IndirectIndexing.time_signed_indirect_indexing": {
        "code": "class IndirectIndexing:\n    def time_signed_indirect_indexing(self):\n        self.targets[:] = 0\n        grouped_sum(self.values, self.labels, self.targets)\n\ndef setup():\n    global grouped_sum\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def grouped_sum(values, labels, target):\n        for i in range(len(values)):\n            idx = labels[i]\n            target[idx] += values[i]\n\nclass IndirectIndexing:\n    def setup(self):\n        n_in = 200000\n        n_out = 20\n        self.values = np.random.RandomState(0).randn(n_in)\n        self.labels = np.random.RandomState(0).randint(n_out, size=n_in).astype('intp')\n        self.unsigned_labels = self.labels.astype('uintp')\n        self.targets = np.zeros(n_out)\n        # Warm up JIT\n        grouped_sum(self.values, self.labels, self.targets)\n        grouped_sum(self.values, self.unsigned_labels, self.targets)",
        "min_run_count": 2,
        "name": "bench_misc.IndirectIndexing.time_signed_indirect_indexing",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "c848c77d33aab0b9b9bb79e1844666967f106f8943626b9e847f24f3839fcce2",
        "warmup_time": -1
    },
    "bench_misc.IndirectIndexing.time_unsigned_indirect_indexing": {
        "code": "class IndirectIndexing:\n    def time_unsigned_indirect_indexing(self):\n        self.targets[:] = 0\n        grouped_sum(self.values, self.unsigned_labels, self.targets)\n\ndef setup():\n    global grouped_sum\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def grouped_sum(values, labels, target):\n        for i in range(len(values)):\n            idx = labels[i]\n            target[idx] += values[i]\n\nclass IndirectIndexing:\n    def setup(self):\n        n_in = 200000\n        n_out = 20\n        self.values = np.random.RandomState(0).randn(n_in)\n        self.labels = np.random.RandomState(0).randint(n_out, size=n_in).astype('intp')\n        self.unsigned_labels = self.labels.astype('uintp')\n        self.targets = np.zeros(n_out)\n        # Warm up JIT\n        grouped_sum(self.values, self.labels, self.targets)\n        grouped_sum(self.values, self.unsigned_labels, self.targets)",
        "min_run_count": 2,
        "name": "bench_misc.IndirectIndexing.time_unsigned_indirect_indexing",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "5a5fd45d00e6fd6e84f37c783f31fa82354a40613500cafea33317e71eb8ed8c",
        "warmup_time": -1
    },
    "bench_misc.InitializationTime.time_new_process_import_numba": {
        "code": "class InitializationTime:\n    def time_new_process_import_numba(self):\n        subprocess.check_call([sys.executable, \"-c\", \"from numba import jit\"])\n\ndef setup():\n    global grouped_sum\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def grouped_sum(values, labels, target):\n        for i in range(len(values)):\n            idx = labels[i]\n            target[idx] += values[i]",
        "min_run_count": 2,
        "name": "bench_misc.InitializationTime.time_new_process_import_numba",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 10,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "bce9fa53e164c1ce7493b320e141d2f1e9ee6b7785f68cad3656962726992b4e",
        "warmup_time": -1
    },
    "bench_nbody.NBody.time_numba_nbody": {
        "code": "class NBody:\n    def time_numba_nbody(self):\n        run_numba_nbody(self.positions, self.weights)\n\ndef setup():\n    global run_numba_nbody\n    from numba import jit, float32, float64\n\n    @jit\n    def run_numba_nbody(positions, weights):\n        accelerations = np.zeros_like(positions)\n        n = weights.shape[0]\n        for i in range(n):\n            ax = zero\n            ay = zero\n            for j in range(n):\n                rx = positions[j,0] - positions[i,0]\n                ry = positions[j,1] - positions[i,1]\n                sqr_dist = rx * rx + ry * ry + eps_2\n                sixth_dist = sqr_dist * sqr_dist * sqr_dist\n                inv_dist_cube = one / math.sqrt(sixth_dist)\n                s = weights[j] * inv_dist_cube\n                ax += s * rx\n                ay += s * ry\n            accelerations[i,0] = ax\n            accelerations[i,1] = ay\n        return accelerations\n\nclass NBody:\n    def setup(self):\n        # Sanity check our implementation\n        p, w = make_nbody_samples(10)\n        numba_res = run_numba_nbody(p, w)\n        numpy_res = run_numpy_nbody(p, w)\n        assert np.allclose(numba_res, numpy_res, 1e-4), (numba_res, numpy_res)\n        # Actual benchmark samples\n        self.positions, self.weights = make_nbody_samples(self.n_bodies)",
        "min_run_count": 2,
        "name": "bench_nbody.NBody.time_numba_nbody",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "e43286be859ba1f38e7569048bc725b5eb72156a4ea458361d8b27f24b1f6d68",
        "warmup_time": -1
    },
    "bench_numbagg.Numbagg.time_move_nanmean": {
        "code": "class Numbagg:\n    def time_move_nanmean(self):\n        arr = some_nans\n        res = move_nanmean(arr, np.asarray(10))\n        assert res.shape == arr.shape\n\ndef setup():\n    \"\"\"\n    Precompile jitted functions.\n    \"\"\"\n    jit_setup()\n    nanmean(some_nans)",
        "min_run_count": 2,
        "name": "bench_numbagg.Numbagg.time_move_nanmean",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7c3ce09b1d7140d12d3b89e7c9b4ae0f62405ba1b8d40e936914f53502878bb5",
        "warmup_time": -1
    },
    "bench_numbagg.Numbagg.time_move_nanmean_2d": {
        "code": "class Numbagg:\n    def time_move_nanmean_2d(self):\n        arr = some_nans_2d\n        res = move_nanmean(arr, np.asarray(10))\n        assert res.shape == arr.shape\n\ndef setup():\n    \"\"\"\n    Precompile jitted functions.\n    \"\"\"\n    jit_setup()\n    nanmean(some_nans)",
        "min_run_count": 2,
        "name": "bench_numbagg.Numbagg.time_move_nanmean_2d",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "9127f5a63a112bd27ed69d021e9875e9dfde44475e963ed382178fd36fa134a5",
        "warmup_time": -1
    },
    "bench_numbagg.Numbagg.time_nanmean_gufunc": {
        "code": "class Numbagg:\n    def time_nanmean_gufunc(self):\n        gu_nanmean(some_nans_2d)\n\ndef setup():\n    \"\"\"\n    Precompile jitted functions.\n    \"\"\"\n    jit_setup()\n    nanmean(some_nans)",
        "min_run_count": 2,
        "name": "bench_numbagg.Numbagg.time_nanmean_gufunc",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b4b856c084a01b144074378186f27cd92845d0e7a0f36ed890bf53dfe616ba13",
        "warmup_time": -1
    },
    "bench_numbagg.Numbagg.time_nanmean_jit_1d": {
        "code": "class Numbagg:\n    def time_nanmean_jit_1d(self):\n        nanmean(some_nans)\n\ndef setup():\n    \"\"\"\n    Precompile jitted functions.\n    \"\"\"\n    jit_setup()\n    nanmean(some_nans)",
        "min_run_count": 2,
        "name": "bench_numbagg.Numbagg.time_nanmean_jit_1d",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "9deb090b8969c471dcdbed8d23d1a3fe9562af667973290c88625433a45c23da",
        "warmup_time": -1
    },
    "bench_numbagg.Numbagg.time_nanmean_jit_2d": {
        "code": "class Numbagg:\n    def time_nanmean_jit_2d(self):\n        nanmean(some_nans_2d)\n\ndef setup():\n    \"\"\"\n    Precompile jitted functions.\n    \"\"\"\n    jit_setup()\n    nanmean(some_nans)",
        "min_run_count": 2,
        "name": "bench_numbagg.Numbagg.time_nanmean_jit_2d",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "67abe608cfcd4166f2e1c37f0f254d34b18fd9521fbdf1d13d99d32762726efc",
        "warmup_time": -1
    },
    "bench_numbagg.Numbagg.time_nanmean_jit_2d_reversed": {
        "code": "class Numbagg:\n    def time_nanmean_jit_2d_reversed(self):\n        nanmean(some_nans_2d_reversed)\n\ndef setup():\n    \"\"\"\n    Precompile jitted functions.\n    \"\"\"\n    jit_setup()\n    nanmean(some_nans)",
        "min_run_count": 2,
        "name": "bench_numbagg.Numbagg.time_nanmean_jit_2d_reversed",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "485ad96473144c1690a1975b21c7b159b1a96080adc9b9b15b86100e9ee70b70",
        "warmup_time": -1
    },
    "bench_random.RandomIntegers.time_py_getrandbits": {
        "code": "class RandomIntegers:\n    def time_py_getrandbits(self):\n        py_getrandbits(42, 100000)\n\ndef setup():\n    global py_getrandbits\n    from numba import jit\n\n    @jit(nopython=True)\n    def py_getrandbits(seed, n):\n        random.seed(seed)\n        s = 0\n        for i in range(n):\n            s += random.getrandbits(32)\n        return s\n\nclass RandomIntegers:\n    def setup(self):\n        # Warm up\n        py_getrandbits(42, 1)",
        "min_run_count": 2,
        "name": "bench_random.RandomIntegers.time_py_getrandbits",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "ca0d32ce1f58b2169f647c1f3360c34b836dd8e09a124aab8eb9e4ad0ef7fa56",
        "warmup_time": -1
    },
    "bench_sets.IntegerSets.time_setops": {
        "code": "class IntegerSets:\n    def time_setops(self):\n        self.run_setops(self.N)\n\ndef setup():\n    global unique, setops\n    from numba import jit\n\n    # Set benchmarks\n    # Notes:\n    # - unless we want to benchmark marshalling a set or list back to Python,\n    #   we return a single value to avoid conversion costs\n\n    @jit(nopython=True)\n    def unique(seq):\n        l = []\n        seen = set()\n        for v in seq:\n            if v not in seen:\n                seen.add(v)\n                l.append(v)\n        return l[-1]\n\n\n    @jit(nopython=True)\n    def setops(a, b):\n        sa = set(a)\n        sb = set(b)\n        return len(sa & sb), len(sa | sb), len(sa ^ sb), len(sa - sb), len(sb - sa)\n\nclass IntegerSets:\n    def setup(self):\n        self.rnd = np.random.RandomState(42)\n        self.seq = self.duplicates_array(self.N)\n        self.a = self.sparse_array(self.N)\n        self.b = self.sparse_array(self.N)\n        # Warm up\n        self.run_unique(5)\n        self.run_setops(5)",
        "min_run_count": 2,
        "name": "bench_sets.IntegerSets.time_setops",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "810664299484441ef9d0bd4f2b51beaa27379f428d37260e7d6554809f69d369",
        "warmup_time": -1
    },
    "bench_sets.IntegerSets.time_unique": {
        "code": "class IntegerSets:\n    def time_unique(self):\n        self.run_unique(self.N)\n\ndef setup():\n    global unique, setops\n    from numba import jit\n\n    # Set benchmarks\n    # Notes:\n    # - unless we want to benchmark marshalling a set or list back to Python,\n    #   we return a single value to avoid conversion costs\n\n    @jit(nopython=True)\n    def unique(seq):\n        l = []\n        seen = set()\n        for v in seq:\n            if v not in seen:\n                seen.add(v)\n                l.append(v)\n        return l[-1]\n\n\n    @jit(nopython=True)\n    def setops(a, b):\n        sa = set(a)\n        sb = set(b)\n        return len(sa & sb), len(sa | sb), len(sa ^ sb), len(sa - sb), len(sb - sa)\n\nclass IntegerSets:\n    def setup(self):\n        self.rnd = np.random.RandomState(42)\n        self.seq = self.duplicates_array(self.N)\n        self.a = self.sparse_array(self.N)\n        self.b = self.sparse_array(self.N)\n        # Warm up\n        self.run_unique(5)\n        self.run_setops(5)",
        "min_run_count": 2,
        "name": "bench_sets.IntegerSets.time_unique",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8aa4862ecb96c398d19ff83a1f3ea8b49116bf1c349397fd6f09593680007584",
        "warmup_time": -1
    },
    "bench_sorting.ArrayMedian.time_median_duplicates_array": {
        "code": "class ArrayMedian:\n    def time_median_duplicates_array(self):\n        \"\"\"\n        Median of a random array with many duplicates.\n        \"\"\"\n        median(self.duplicates_array)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def real_sort(x):\n        x.sort()\n\n    def sort(x):\n        # We *have* to do a copy, otherwise repeating the benchmark will\n        # produce skewed results in the later iterations, as an already-sorted\n        # array will be passed.\n        # We prefer do the copying outside of the JITted function, as we want\n        # to measure sort() performance, not the performance of Numba's copy().\n        real_sort(x.copy())\n\n    @jit(nopython=True)\n    def argsort(x):\n        return x.argsort()\n\n    @jit(nopython=True)\n    def median(x):\n        return np.median(x)\n\n    globals().update(locals())\n\nclass ArrayMedian:\n    def setup(self):\n        BaseArraySorting.setup(self)\n        # Warm up\n        dummy = np.arange(10, dtype=self.dtype)\n        median(dummy)",
        "min_run_count": 2,
        "name": "bench_sorting.ArrayMedian.time_median_duplicates_array",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7c55a6ddcbdcf4e4351d85f1021e222398898e9212806612eff8ea58d346dae7",
        "warmup_time": -1
    },
    "bench_sorting.ArrayMedian.time_median_random_array_even": {
        "code": "class ArrayMedian:\n    def time_median_random_array_even(self):\n        \"\"\"\n        Median of an even-sized random array.\n        \"\"\"\n        arr = self.random_array\n        assert arr.size & 1 == 0\n        median(arr)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def real_sort(x):\n        x.sort()\n\n    def sort(x):\n        # We *have* to do a copy, otherwise repeating the benchmark will\n        # produce skewed results in the later iterations, as an already-sorted\n        # array will be passed.\n        # We prefer do the copying outside of the JITted function, as we want\n        # to measure sort() performance, not the performance of Numba's copy().\n        real_sort(x.copy())\n\n    @jit(nopython=True)\n    def argsort(x):\n        return x.argsort()\n\n    @jit(nopython=True)\n    def median(x):\n        return np.median(x)\n\n    globals().update(locals())\n\nclass ArrayMedian:\n    def setup(self):\n        BaseArraySorting.setup(self)\n        # Warm up\n        dummy = np.arange(10, dtype=self.dtype)\n        median(dummy)",
        "min_run_count": 2,
        "name": "bench_sorting.ArrayMedian.time_median_random_array_even",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d6aaca5f4788a019faac395aafa223252501c6870fc6a8ac2b1e23d30dfc3977",
        "warmup_time": -1
    },
    "bench_sorting.ArrayMedian.time_median_random_array_odd": {
        "code": "class ArrayMedian:\n    def time_median_random_array_odd(self):\n        \"\"\"\n        Median of an odd-sized random array.\n        \"\"\"\n        arr = self.random_array[:-1]\n        assert arr.size & 1 == 1\n        median(arr)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def real_sort(x):\n        x.sort()\n\n    def sort(x):\n        # We *have* to do a copy, otherwise repeating the benchmark will\n        # produce skewed results in the later iterations, as an already-sorted\n        # array will be passed.\n        # We prefer do the copying outside of the JITted function, as we want\n        # to measure sort() performance, not the performance of Numba's copy().\n        real_sort(x.copy())\n\n    @jit(nopython=True)\n    def argsort(x):\n        return x.argsort()\n\n    @jit(nopython=True)\n    def median(x):\n        return np.median(x)\n\n    globals().update(locals())\n\nclass ArrayMedian:\n    def setup(self):\n        BaseArraySorting.setup(self)\n        # Warm up\n        dummy = np.arange(10, dtype=self.dtype)\n        median(dummy)",
        "min_run_count": 2,
        "name": "bench_sorting.ArrayMedian.time_median_random_array_odd",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "52af579d33d02db32c27cd13bcf51e6642de38d3f6ae5f77b2afbf4caa48da66",
        "warmup_time": -1
    },
    "bench_sorting.ArrayMedian.time_median_sorted_array": {
        "code": "class ArrayMedian:\n    def time_median_sorted_array(self):\n        \"\"\"\n        Median of a sorted array.\n        \"\"\"\n        median(self.sorted_array)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def real_sort(x):\n        x.sort()\n\n    def sort(x):\n        # We *have* to do a copy, otherwise repeating the benchmark will\n        # produce skewed results in the later iterations, as an already-sorted\n        # array will be passed.\n        # We prefer do the copying outside of the JITted function, as we want\n        # to measure sort() performance, not the performance of Numba's copy().\n        real_sort(x.copy())\n\n    @jit(nopython=True)\n    def argsort(x):\n        return x.argsort()\n\n    @jit(nopython=True)\n    def median(x):\n        return np.median(x)\n\n    globals().update(locals())\n\nclass ArrayMedian:\n    def setup(self):\n        BaseArraySorting.setup(self)\n        # Warm up\n        dummy = np.arange(10, dtype=self.dtype)\n        median(dummy)",
        "min_run_count": 2,
        "name": "bench_sorting.ArrayMedian.time_median_sorted_array",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "38180194e8239497e7b3c9f0d5c0c4f5c7dfa27c3e7873d6d570cd9818fbfe03",
        "warmup_time": -1
    },
    "bench_sorting.ArrayMedian.time_median_triangle_array": {
        "code": "class ArrayMedian:\n    def time_median_triangle_array(self):\n        \"\"\"\n        Median of a \"triangular\" array: ascending then descending.\n        \"\"\"\n        median(self.triangle_array)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def real_sort(x):\n        x.sort()\n\n    def sort(x):\n        # We *have* to do a copy, otherwise repeating the benchmark will\n        # produce skewed results in the later iterations, as an already-sorted\n        # array will be passed.\n        # We prefer do the copying outside of the JITted function, as we want\n        # to measure sort() performance, not the performance of Numba's copy().\n        real_sort(x.copy())\n\n    @jit(nopython=True)\n    def argsort(x):\n        return x.argsort()\n\n    @jit(nopython=True)\n    def median(x):\n        return np.median(x)\n\n    globals().update(locals())\n\nclass ArrayMedian:\n    def setup(self):\n        BaseArraySorting.setup(self)\n        # Warm up\n        dummy = np.arange(10, dtype=self.dtype)\n        median(dummy)",
        "min_run_count": 2,
        "name": "bench_sorting.ArrayMedian.time_median_triangle_array",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "cfda6aceb4c5764c6c53e7a0a2619ec9470d9cc913ee8e0ae70143d0ca9f1d7a",
        "warmup_time": -1
    },
    "bench_sorting.ArraySorting.time_argsort_random_array": {
        "code": "class ArraySorting:\n    def time_argsort_random_array(self):\n        \"\"\"\n        Arg-sort a random array.\n        \"\"\"\n        argsort(self.random_array)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def real_sort(x):\n        x.sort()\n\n    def sort(x):\n        # We *have* to do a copy, otherwise repeating the benchmark will\n        # produce skewed results in the later iterations, as an already-sorted\n        # array will be passed.\n        # We prefer do the copying outside of the JITted function, as we want\n        # to measure sort() performance, not the performance of Numba's copy().\n        real_sort(x.copy())\n\n    @jit(nopython=True)\n    def argsort(x):\n        return x.argsort()\n\n    @jit(nopython=True)\n    def median(x):\n        return np.median(x)\n\n    globals().update(locals())\n\nclass ArraySorting:\n    def setup(self):\n        BaseArraySorting.setup(self)\n        # Warm up\n        dummy = np.arange(10, dtype=self.dtype)\n        sort(dummy)\n        argsort(dummy)",
        "min_run_count": 2,
        "name": "bench_sorting.ArraySorting.time_argsort_random_array",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b00a8d924025676739ee661c08a5f49f91ce9d1f3b42e5ccad383247c8cd3664",
        "warmup_time": -1
    },
    "bench_sorting.ArraySorting.time_sort_duplicates_array": {
        "code": "class ArraySorting:\n    def time_sort_duplicates_array(self):\n        \"\"\"\n        Sort a random array with many duplicates.\n        \"\"\"\n        sort(self.duplicates_array)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def real_sort(x):\n        x.sort()\n\n    def sort(x):\n        # We *have* to do a copy, otherwise repeating the benchmark will\n        # produce skewed results in the later iterations, as an already-sorted\n        # array will be passed.\n        # We prefer do the copying outside of the JITted function, as we want\n        # to measure sort() performance, not the performance of Numba's copy().\n        real_sort(x.copy())\n\n    @jit(nopython=True)\n    def argsort(x):\n        return x.argsort()\n\n    @jit(nopython=True)\n    def median(x):\n        return np.median(x)\n\n    globals().update(locals())\n\nclass ArraySorting:\n    def setup(self):\n        BaseArraySorting.setup(self)\n        # Warm up\n        dummy = np.arange(10, dtype=self.dtype)\n        sort(dummy)\n        argsort(dummy)",
        "min_run_count": 2,
        "name": "bench_sorting.ArraySorting.time_sort_duplicates_array",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "6219a390b08997066efe5e3d40607bc50ef45b877d526d1f793a7eea4d72ac4a",
        "warmup_time": -1
    },
    "bench_sorting.ArraySorting.time_sort_random_array": {
        "code": "class ArraySorting:\n    def time_sort_random_array(self):\n        \"\"\"\n        Sort a random array.\n        \"\"\"\n        sort(self.random_array)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def real_sort(x):\n        x.sort()\n\n    def sort(x):\n        # We *have* to do a copy, otherwise repeating the benchmark will\n        # produce skewed results in the later iterations, as an already-sorted\n        # array will be passed.\n        # We prefer do the copying outside of the JITted function, as we want\n        # to measure sort() performance, not the performance of Numba's copy().\n        real_sort(x.copy())\n\n    @jit(nopython=True)\n    def argsort(x):\n        return x.argsort()\n\n    @jit(nopython=True)\n    def median(x):\n        return np.median(x)\n\n    globals().update(locals())\n\nclass ArraySorting:\n    def setup(self):\n        BaseArraySorting.setup(self)\n        # Warm up\n        dummy = np.arange(10, dtype=self.dtype)\n        sort(dummy)\n        argsort(dummy)",
        "min_run_count": 2,
        "name": "bench_sorting.ArraySorting.time_sort_random_array",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b9b7668f705e26583a4fcfaabca4d0dd1f5dadb69001699777113d5f4d311731",
        "warmup_time": -1
    },
    "bench_sorting.ArraySorting.time_sort_sorted_array": {
        "code": "class ArraySorting:\n    def time_sort_sorted_array(self):\n        \"\"\"\n        Sort an already sorted array.\n        \"\"\"\n        sort(self.sorted_array)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def real_sort(x):\n        x.sort()\n\n    def sort(x):\n        # We *have* to do a copy, otherwise repeating the benchmark will\n        # produce skewed results in the later iterations, as an already-sorted\n        # array will be passed.\n        # We prefer do the copying outside of the JITted function, as we want\n        # to measure sort() performance, not the performance of Numba's copy().\n        real_sort(x.copy())\n\n    @jit(nopython=True)\n    def argsort(x):\n        return x.argsort()\n\n    @jit(nopython=True)\n    def median(x):\n        return np.median(x)\n\n    globals().update(locals())\n\nclass ArraySorting:\n    def setup(self):\n        BaseArraySorting.setup(self)\n        # Warm up\n        dummy = np.arange(10, dtype=self.dtype)\n        sort(dummy)\n        argsort(dummy)",
        "min_run_count": 2,
        "name": "bench_sorting.ArraySorting.time_sort_sorted_array",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1d688918ae012b6ef28b45ba2d08c6a1a23102d1df5c7e443b423b63ca09db35",
        "warmup_time": -1
    },
    "bench_sorting.ArraySorting.time_sort_triangle_array": {
        "code": "class ArraySorting:\n    def time_sort_triangle_array(self):\n        \"\"\"\n        Sort a \"triangular\" array: ascending then descending.\n        \"\"\"\n        sort(self.triangle_array)\n\ndef setup():\n    from numba import jit\n\n\n    @jit(nopython=True)\n    def real_sort(x):\n        x.sort()\n\n    def sort(x):\n        # We *have* to do a copy, otherwise repeating the benchmark will\n        # produce skewed results in the later iterations, as an already-sorted\n        # array will be passed.\n        # We prefer do the copying outside of the JITted function, as we want\n        # to measure sort() performance, not the performance of Numba's copy().\n        real_sort(x.copy())\n\n    @jit(nopython=True)\n    def argsort(x):\n        return x.argsort()\n\n    @jit(nopython=True)\n    def median(x):\n        return np.median(x)\n\n    globals().update(locals())\n\nclass ArraySorting:\n    def setup(self):\n        BaseArraySorting.setup(self)\n        # Warm up\n        dummy = np.arange(10, dtype=self.dtype)\n        sort(dummy)\n        argsort(dummy)",
        "min_run_count": 2,
        "name": "bench_sorting.ArraySorting.time_sort_triangle_array",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "51453ec5e519d7276da22b4e98d6b5bc1ce8f16c1fc99769713d008ea570ea34",
        "warmup_time": -1
    },
    "bench_typed_list.ArrayListSuite.time_compile_reduction_sum_fastmath": {
        "code": "class ReductionSuite:\n    def time_compile_reduction_sum_fastmath(self):\n        self.fastmath_dispatcher.compile(self.signature)\n\nclass ArrayListSuite:\n    def setup(self):\n    \n        self.tl = make_random_typed_list_array(SIZE/100)\n        self.signature = Signature(float64, [ListType(Array(float64, 1, 'C'))], None)\n        self.post_setup()",
        "min_run_count": 5,
        "name": "bench_typed_list.ArrayListSuite.time_compile_reduction_sum_fastmath",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "2b3de07303cc7a3b925e9c2a526830c163c24fcce191c2b54baf8b66f71a8d72",
        "warmup_time": 0.0
    },
    "bench_typed_list.ArrayListSuite.time_compile_reduction_sum_no_fastmath": {
        "code": "class ReductionSuite:\n    def time_compile_reduction_sum_no_fastmath(self):\n        self.no_fastmath_dispatcher.compile(self.signature)\n\nclass ArrayListSuite:\n    def setup(self):\n    \n        self.tl = make_random_typed_list_array(SIZE/100)\n        self.signature = Signature(float64, [ListType(Array(float64, 1, 'C'))], None)\n        self.post_setup()",
        "min_run_count": 5,
        "name": "bench_typed_list.ArrayListSuite.time_compile_reduction_sum_no_fastmath",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "19546031a634f75f4c7e1dcdf3eee71d0337032ea843d7f9a77f51f5b1f2c54a",
        "warmup_time": 0.0
    },
    "bench_typed_list.ArrayListSuite.time_execute_reduction_sum_fastmath": {
        "code": "class ReductionSuite:\n    def time_execute_reduction_sum_fastmath(self):\n        self.reduction_sum_fastmath(self.tl)\n\nclass ArrayListSuite:\n    def setup(self):\n    \n        self.tl = make_random_typed_list_array(SIZE/100)\n        self.signature = Signature(float64, [ListType(Array(float64, 1, 'C'))], None)\n        self.post_setup()",
        "min_run_count": 5,
        "name": "bench_typed_list.ArrayListSuite.time_execute_reduction_sum_fastmath",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "93aa86d5a4275fe3befabf461306d4a9798356755a751e76e828da3819b3b732",
        "warmup_time": 0.0
    },
    "bench_typed_list.ArrayListSuite.time_execute_reduction_sum_no_fastmath": {
        "code": "class ReductionSuite:\n    def time_execute_reduction_sum_no_fastmath(self):\n        self.reduction_sum_no_fastmath(self.tl)\n\nclass ArrayListSuite:\n    def setup(self):\n    \n        self.tl = make_random_typed_list_array(SIZE/100)\n        self.signature = Signature(float64, [ListType(Array(float64, 1, 'C'))], None)\n        self.post_setup()",
        "min_run_count": 5,
        "name": "bench_typed_list.ArrayListSuite.time_execute_reduction_sum_no_fastmath",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "33cce24204683d7692f9c4528e2cb86a7a94ee8cf954582aa022edc52e035d60",
        "warmup_time": 0.0
    },
    "bench_typed_list.ConstructionSuite.time_construct_from_python_list": {
        "code": "class ConstructionSuite:\n    def time_construct_from_python_list(self):\n        List(self.pl)\n\n    def setup(self):\n        self.pl = make_random_python_list(SIZE)\n        List(self.pl)",
        "min_run_count": 5,
        "name": "bench_typed_list.ConstructionSuite.time_construct_from_python_list",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "927b3b7c24dc00737780ab8e30e9860afab6497cb0015fe5e2dd540d26f0c625",
        "warmup_time": 0.0
    },
    "bench_typed_list.ConstructionSuite.time_construct_in_njit_function": {
        "code": "class ConstructionSuite:\n    def time_construct_in_njit_function(self):\n        make_random_typed_list_int(SIZE)\n\n    def setup(self):\n        self.pl = make_random_python_list(SIZE)\n        List(self.pl)",
        "min_run_count": 5,
        "name": "bench_typed_list.ConstructionSuite.time_construct_in_njit_function",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "8925f7e504013cb6ccd9c03220161ecf1bf7032c7bf99ef3b753a9bb95c69d3c",
        "warmup_time": 0.0
    },
    "bench_typed_list.ForLoopReductionSuiteFloat.time_compile_reduction_sum_fastmath": {
        "code": "class ReductionSuite:\n    def time_compile_reduction_sum_fastmath(self):\n        self.fastmath_dispatcher.compile(self.signature)\n\nclass ForLoopReductionSuiteFloat:\n    def setup(self):\n    \n        self.tl = make_random_typed_list_float(SIZE)\n        self.signature = Signature(float64, [ListType(float64)], None)\n        self.post_setup()",
        "min_run_count": 5,
        "name": "bench_typed_list.ForLoopReductionSuiteFloat.time_compile_reduction_sum_fastmath",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "132c8a7aef7aaf17e782d3c4fe570a79ad83fb785946b689e2afc7bd8d3f62dd",
        "warmup_time": 0.0
    },
    "bench_typed_list.ForLoopReductionSuiteFloat.time_compile_reduction_sum_no_fastmath": {
        "code": "class ReductionSuite:\n    def time_compile_reduction_sum_no_fastmath(self):\n        self.no_fastmath_dispatcher.compile(self.signature)\n\nclass ForLoopReductionSuiteFloat:\n    def setup(self):\n    \n        self.tl = make_random_typed_list_float(SIZE)\n        self.signature = Signature(float64, [ListType(float64)], None)\n        self.post_setup()",
        "min_run_count": 5,
        "name": "bench_typed_list.ForLoopReductionSuiteFloat.time_compile_reduction_sum_no_fastmath",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "c5aefddd381c7a9130e7fb0796e75717da9eb25384bfeb31d749cdaf62923221",
        "warmup_time": 0.0
    },
    "bench_typed_list.ForLoopReductionSuiteFloat.time_execute_reduction_sum_fastmath": {
        "code": "class ReductionSuite:\n    def time_execute_reduction_sum_fastmath(self):\n        self.reduction_sum_fastmath(self.tl)\n\nclass ForLoopReductionSuiteFloat:\n    def setup(self):\n    \n        self.tl = make_random_typed_list_float(SIZE)\n        self.signature = Signature(float64, [ListType(float64)], None)\n        self.post_setup()",
        "min_run_count": 5,
        "name": "bench_typed_list.ForLoopReductionSuiteFloat.time_execute_reduction_sum_fastmath",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "e1d5db77c528f666d15cfedab731a6c3000516e64471cdc9a351d5ecc935219a",
        "warmup_time": 0.0
    },
    "bench_typed_list.ForLoopReductionSuiteFloat.time_execute_reduction_sum_no_fastmath": {
        "code": "class ReductionSuite:\n    def time_execute_reduction_sum_no_fastmath(self):\n        self.reduction_sum_no_fastmath(self.tl)\n\nclass ForLoopReductionSuiteFloat:\n    def setup(self):\n    \n        self.tl = make_random_typed_list_float(SIZE)\n        self.signature = Signature(float64, [ListType(float64)], None)\n        self.post_setup()",
        "min_run_count": 5,
        "name": "bench_typed_list.ForLoopReductionSuiteFloat.time_execute_reduction_sum_no_fastmath",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b871e21598e1e295be60b5fe12d376786355a060644d30ba1a9d48499a935164",
        "warmup_time": 0.0
    },
    "bench_typed_list.ForLoopReductionSuiteInt.time_compile_reduction_sum_fastmath": {
        "code": "class ReductionSuite:\n    def time_compile_reduction_sum_fastmath(self):\n        self.fastmath_dispatcher.compile(self.signature)\n\nclass ForLoopReductionSuiteInt:\n    def setup(self):\n    \n        self.tl = make_random_typed_list_int(SIZE)\n        self.signature = Signature(int64, [ListType(int64)], None)\n        self.post_setup()",
        "min_run_count": 5,
        "name": "bench_typed_list.ForLoopReductionSuiteInt.time_compile_reduction_sum_fastmath",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d3a032dff50bf65b887f17e704db1842dc042ea276dfcf6e3c3cc63b91e02908",
        "warmup_time": 0.0
    },
    "bench_typed_list.ForLoopReductionSuiteInt.time_compile_reduction_sum_no_fastmath": {
        "code": "class ReductionSuite:\n    def time_compile_reduction_sum_no_fastmath(self):\n        self.no_fastmath_dispatcher.compile(self.signature)\n\nclass ForLoopReductionSuiteInt:\n    def setup(self):\n    \n        self.tl = make_random_typed_list_int(SIZE)\n        self.signature = Signature(int64, [ListType(int64)], None)\n        self.post_setup()",
        "min_run_count": 5,
        "name": "bench_typed_list.ForLoopReductionSuiteInt.time_compile_reduction_sum_no_fastmath",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b3139454f53c70fa3ce23d2fc22ac73f54a1bb75e865cfe880e08ba9ad58231c",
        "warmup_time": 0.0
    },
    "bench_typed_list.ForLoopReductionSuiteInt.time_execute_reduction_sum_fastmath": {
        "code": "class ReductionSuite:\n    def time_execute_reduction_sum_fastmath(self):\n        self.reduction_sum_fastmath(self.tl)\n\nclass ForLoopReductionSuiteInt:\n    def setup(self):\n    \n        self.tl = make_random_typed_list_int(SIZE)\n        self.signature = Signature(int64, [ListType(int64)], None)\n        self.post_setup()",
        "min_run_count": 5,
        "name": "bench_typed_list.ForLoopReductionSuiteInt.time_execute_reduction_sum_fastmath",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7ef55597259cc403ba46c12a260dd92cf5281f0fc4082c85ac528e290073c86d",
        "warmup_time": 0.0
    },
    "bench_typed_list.ForLoopReductionSuiteInt.time_execute_reduction_sum_no_fastmath": {
        "code": "class ReductionSuite:\n    def time_execute_reduction_sum_no_fastmath(self):\n        self.reduction_sum_no_fastmath(self.tl)\n\nclass ForLoopReductionSuiteInt:\n    def setup(self):\n    \n        self.tl = make_random_typed_list_int(SIZE)\n        self.signature = Signature(int64, [ListType(int64)], None)\n        self.post_setup()",
        "min_run_count": 5,
        "name": "bench_typed_list.ForLoopReductionSuiteInt.time_execute_reduction_sum_no_fastmath",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "e037609d7b4d7e8fbabd66d2a05465707d0f6c0855710f0773d6222e418d2a31",
        "warmup_time": 0.0
    },
    "bench_typed_list.GetitemUncheckedReductionSuiteFloat.time_compile_reduction_sum_fastmath": {
        "code": "class ReductionSuite:\n    def time_compile_reduction_sum_fastmath(self):\n        self.fastmath_dispatcher.compile(self.signature)\n\nclass GetitemUncheckedReductionSuiteFloat:\n    def setup(self):\n    \n        self.tl = make_random_typed_list_float(SIZE)\n        self.signature = Signature(float64, [ListType(float64)], None)\n        self.post_setup()",
        "min_run_count": 5,
        "name": "bench_typed_list.GetitemUncheckedReductionSuiteFloat.time_compile_reduction_sum_fastmath",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "974193ee42a5ede7c378ca3e683ad4354e9c248c753dd92ca4906bad7a2719e8",
        "warmup_time": 0.0
    },
    "bench_typed_list.GetitemUncheckedReductionSuiteFloat.time_compile_reduction_sum_no_fastmath": {
        "code": "class ReductionSuite:\n    def time_compile_reduction_sum_no_fastmath(self):\n        self.no_fastmath_dispatcher.compile(self.signature)\n\nclass GetitemUncheckedReductionSuiteFloat:\n    def setup(self):\n    \n        self.tl = make_random_typed_list_float(SIZE)\n        self.signature = Signature(float64, [ListType(float64)], None)\n        self.post_setup()",
        "min_run_count": 5,
        "name": "bench_typed_list.GetitemUncheckedReductionSuiteFloat.time_compile_reduction_sum_no_fastmath",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "cc488a3eb4d7783d1fd0c0cc6a5ee93d182213e2e9e7415409538f58560a7fc1",
        "warmup_time": 0.0
    },
    "bench_typed_list.GetitemUncheckedReductionSuiteFloat.time_execute_reduction_sum_fastmath": {
        "code": "class ReductionSuite:\n    def time_execute_reduction_sum_fastmath(self):\n        self.reduction_sum_fastmath(self.tl)\n\nclass GetitemUncheckedReductionSuiteFloat:\n    def setup(self):\n    \n        self.tl = make_random_typed_list_float(SIZE)\n        self.signature = Signature(float64, [ListType(float64)], None)\n        self.post_setup()",
        "min_run_count": 5,
        "name": "bench_typed_list.GetitemUncheckedReductionSuiteFloat.time_execute_reduction_sum_fastmath",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "c7d4ea51df813e3805fe8276b1d560ea06bbc66990213bd9fc7f3397dfff3543",
        "warmup_time": 0.0
    },
    "bench_typed_list.GetitemUncheckedReductionSuiteFloat.time_execute_reduction_sum_no_fastmath": {
        "code": "class ReductionSuite:\n    def time_execute_reduction_sum_no_fastmath(self):\n        self.reduction_sum_no_fastmath(self.tl)\n\nclass GetitemUncheckedReductionSuiteFloat:\n    def setup(self):\n    \n        self.tl = make_random_typed_list_float(SIZE)\n        self.signature = Signature(float64, [ListType(float64)], None)\n        self.post_setup()",
        "min_run_count": 5,
        "name": "bench_typed_list.GetitemUncheckedReductionSuiteFloat.time_execute_reduction_sum_no_fastmath",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "b88d61e20ddd7a20899b47ff0de92b1cd6cddac431d6718fbd2ab87172af986f",
        "warmup_time": 0.0
    },
    "bench_typed_list.GetitemUncheckedReductionSuiteInt.time_compile_reduction_sum_fastmath": {
        "code": "class ReductionSuite:\n    def time_compile_reduction_sum_fastmath(self):\n        self.fastmath_dispatcher.compile(self.signature)\n\nclass GetitemUncheckedReductionSuiteInt:\n    def setup(self):\n    \n        self.tl = make_random_typed_list_int(SIZE)\n        self.signature = Signature(int64, [ListType(int64)], None)\n        self.post_setup()",
        "min_run_count": 5,
        "name": "bench_typed_list.GetitemUncheckedReductionSuiteInt.time_compile_reduction_sum_fastmath",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "ed1fc221e2c6286ba5825ddaeb8d8c09f9bba80360a94214b870b0cf44174a31",
        "warmup_time": 0.0
    },
    "bench_typed_list.GetitemUncheckedReductionSuiteInt.time_compile_reduction_sum_no_fastmath": {
        "code": "class ReductionSuite:\n    def time_compile_reduction_sum_no_fastmath(self):\n        self.no_fastmath_dispatcher.compile(self.signature)\n\nclass GetitemUncheckedReductionSuiteInt:\n    def setup(self):\n    \n        self.tl = make_random_typed_list_int(SIZE)\n        self.signature = Signature(int64, [ListType(int64)], None)\n        self.post_setup()",
        "min_run_count": 5,
        "name": "bench_typed_list.GetitemUncheckedReductionSuiteInt.time_compile_reduction_sum_no_fastmath",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "75ecade6f4a2ad789833eeec65f293f7b53bfb51a4e801f3cfb1870c31432581",
        "warmup_time": 0.0
    },
    "bench_typed_list.GetitemUncheckedReductionSuiteInt.time_execute_reduction_sum_fastmath": {
        "code": "class ReductionSuite:\n    def time_execute_reduction_sum_fastmath(self):\n        self.reduction_sum_fastmath(self.tl)\n\nclass GetitemUncheckedReductionSuiteInt:\n    def setup(self):\n    \n        self.tl = make_random_typed_list_int(SIZE)\n        self.signature = Signature(int64, [ListType(int64)], None)\n        self.post_setup()",
        "min_run_count": 5,
        "name": "bench_typed_list.GetitemUncheckedReductionSuiteInt.time_execute_reduction_sum_fastmath",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7b2d6d40c8624f583ee34ff9b5eec5a58cfc19d519bc52c9c8e6105c785d1c08",
        "warmup_time": 0.0
    },
    "bench_typed_list.GetitemUncheckedReductionSuiteInt.time_execute_reduction_sum_no_fastmath": {
        "code": "class ReductionSuite:\n    def time_execute_reduction_sum_no_fastmath(self):\n        self.reduction_sum_no_fastmath(self.tl)\n\nclass GetitemUncheckedReductionSuiteInt:\n    def setup(self):\n    \n        self.tl = make_random_typed_list_int(SIZE)\n        self.signature = Signature(int64, [ListType(int64)], None)\n        self.post_setup()",
        "min_run_count": 5,
        "name": "bench_typed_list.GetitemUncheckedReductionSuiteInt.time_execute_reduction_sum_no_fastmath",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d3f0f6cef69a8416b1e5f5d240c70f4407ce44f80d6a6bc448b2328ab2d2fb69",
        "warmup_time": 0.0
    },
    "bench_typed_list.IteratorReductionSuiteFloat.time_compile_reduction_sum_fastmath": {
        "code": "class ReductionSuite:\n    def time_compile_reduction_sum_fastmath(self):\n        self.fastmath_dispatcher.compile(self.signature)\n\nclass IteratorReductionSuiteFloat:\n    def setup(self):\n    \n        self.tl = make_random_typed_list_float(SIZE)\n        self.signature = Signature(float64, [ListType(float64)], None)\n        self.post_setup()",
        "min_run_count": 5,
        "name": "bench_typed_list.IteratorReductionSuiteFloat.time_compile_reduction_sum_fastmath",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "2ce34712d4d2e6eb35c77e397954f6370154e4092898d0626ac80552bbc6a5b3",
        "warmup_time": 0.0
    },
    "bench_typed_list.IteratorReductionSuiteFloat.time_compile_reduction_sum_no_fastmath": {
        "code": "class ReductionSuite:\n    def time_compile_reduction_sum_no_fastmath(self):\n        self.no_fastmath_dispatcher.compile(self.signature)\n\nclass IteratorReductionSuiteFloat:\n    def setup(self):\n    \n        self.tl = make_random_typed_list_float(SIZE)\n        self.signature = Signature(float64, [ListType(float64)], None)\n        self.post_setup()",
        "min_run_count": 5,
        "name": "bench_typed_list.IteratorReductionSuiteFloat.time_compile_reduction_sum_no_fastmath",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "34100e0771dafc28872860682d42c41b9a11e4191fbab1588d5c6bfa98300589",
        "warmup_time": 0.0
    },
    "bench_typed_list.IteratorReductionSuiteFloat.time_execute_reduction_sum_fastmath": {
        "code": "class ReductionSuite:\n    def time_execute_reduction_sum_fastmath(self):\n        self.reduction_sum_fastmath(self.tl)\n\nclass IteratorReductionSuiteFloat:\n    def setup(self):\n    \n        self.tl = make_random_typed_list_float(SIZE)\n        self.signature = Signature(float64, [ListType(float64)], None)\n        self.post_setup()",
        "min_run_count": 5,
        "name": "bench_typed_list.IteratorReductionSuiteFloat.time_execute_reduction_sum_fastmath",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "281a1b00388f3e041d03535da751941ff61234186b10386204fe6fa2f8c4faac",
        "warmup_time": 0.0
    },
    "bench_typed_list.IteratorReductionSuiteFloat.time_execute_reduction_sum_no_fastmath": {
        "code": "class ReductionSuite:\n    def time_execute_reduction_sum_no_fastmath(self):\n        self.reduction_sum_no_fastmath(self.tl)\n\nclass IteratorReductionSuiteFloat:\n    def setup(self):\n    \n        self.tl = make_random_typed_list_float(SIZE)\n        self.signature = Signature(float64, [ListType(float64)], None)\n        self.post_setup()",
        "min_run_count": 5,
        "name": "bench_typed_list.IteratorReductionSuiteFloat.time_execute_reduction_sum_no_fastmath",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "08925beb1152c9b79ec7b6da68cbc290b23f1fd70f7e945aed5453576f1cf6f0",
        "warmup_time": 0.0
    },
    "bench_typed_list.IteratorReductionSuiteInt.time_compile_reduction_sum_fastmath": {
        "code": "class ReductionSuite:\n    def time_compile_reduction_sum_fastmath(self):\n        self.fastmath_dispatcher.compile(self.signature)\n\nclass IteratorReductionSuiteInt:\n    def setup(self):\n    \n        self.tl = make_random_typed_list_int(SIZE)\n        self.signature = Signature(int64, [ListType(int64)], None)\n        self.post_setup()",
        "min_run_count": 5,
        "name": "bench_typed_list.IteratorReductionSuiteInt.time_compile_reduction_sum_fastmath",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "f8ab014467ee203219f0bc54cdb7a1d0ef8475834a5400bb488d6d53618803ec",
        "warmup_time": 0.0
    },
    "bench_typed_list.IteratorReductionSuiteInt.time_compile_reduction_sum_no_fastmath": {
        "code": "class ReductionSuite:\n    def time_compile_reduction_sum_no_fastmath(self):\n        self.no_fastmath_dispatcher.compile(self.signature)\n\nclass IteratorReductionSuiteInt:\n    def setup(self):\n    \n        self.tl = make_random_typed_list_int(SIZE)\n        self.signature = Signature(int64, [ListType(int64)], None)\n        self.post_setup()",
        "min_run_count": 5,
        "name": "bench_typed_list.IteratorReductionSuiteInt.time_compile_reduction_sum_no_fastmath",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "41e8a8f60a8e2edf7511f0e55ea11a56599e5b737ad10cba26d3b933905620ff",
        "warmup_time": 0.0
    },
    "bench_typed_list.IteratorReductionSuiteInt.time_execute_reduction_sum_fastmath": {
        "code": "class ReductionSuite:\n    def time_execute_reduction_sum_fastmath(self):\n        self.reduction_sum_fastmath(self.tl)\n\nclass IteratorReductionSuiteInt:\n    def setup(self):\n    \n        self.tl = make_random_typed_list_int(SIZE)\n        self.signature = Signature(int64, [ListType(int64)], None)\n        self.post_setup()",
        "min_run_count": 5,
        "name": "bench_typed_list.IteratorReductionSuiteInt.time_execute_reduction_sum_fastmath",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "1111eec5cab7d5081c82268176efbdbffd5133b9084710c67fcf8f0ec21a51f1",
        "warmup_time": 0.0
    },
    "bench_typed_list.IteratorReductionSuiteInt.time_execute_reduction_sum_no_fastmath": {
        "code": "class ReductionSuite:\n    def time_execute_reduction_sum_no_fastmath(self):\n        self.reduction_sum_no_fastmath(self.tl)\n\nclass IteratorReductionSuiteInt:\n    def setup(self):\n    \n        self.tl = make_random_typed_list_int(SIZE)\n        self.signature = Signature(int64, [ListType(int64)], None)\n        self.post_setup()",
        "min_run_count": 5,
        "name": "bench_typed_list.IteratorReductionSuiteInt.time_execute_reduction_sum_no_fastmath",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "7fd976c7fc4ef8454464c5da855dc3bf44fcbe2b02b6b6baf67baeae3a2ac125",
        "warmup_time": 0.0
    },
    "bench_typed_list.ReductionSuite.time_compile_reduction_sum_fastmath": {
        "code": "class ReductionSuite:\n    def time_compile_reduction_sum_fastmath(self):\n        self.fastmath_dispatcher.compile(self.signature)\n\n    def setup(self):\n        raise NotImplementedError",
        "min_run_count": 5,
        "name": "bench_typed_list.ReductionSuite.time_compile_reduction_sum_fastmath",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "d89d8352df12a990b37d10eaf2991f8ae41042bbb6c35edd4c67bf5aa2d837e8",
        "warmup_time": 0.0
    },
    "bench_typed_list.ReductionSuite.time_compile_reduction_sum_no_fastmath": {
        "code": "class ReductionSuite:\n    def time_compile_reduction_sum_no_fastmath(self):\n        self.no_fastmath_dispatcher.compile(self.signature)\n\n    def setup(self):\n        raise NotImplementedError",
        "min_run_count": 5,
        "name": "bench_typed_list.ReductionSuite.time_compile_reduction_sum_no_fastmath",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "e3e432740865d715f32bb09d863d096b82160e708c111d8aecba16a9f105401e",
        "warmup_time": 0.0
    },
    "bench_typed_list.ReductionSuite.time_execute_reduction_sum_fastmath": {
        "code": "class ReductionSuite:\n    def time_execute_reduction_sum_fastmath(self):\n        self.reduction_sum_fastmath(self.tl)\n\n    def setup(self):\n        raise NotImplementedError",
        "min_run_count": 5,
        "name": "bench_typed_list.ReductionSuite.time_execute_reduction_sum_fastmath",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "9728ca4dc0edcf8c998483dd16996815aca9ba69a46b4711597d5c96408abe1c",
        "warmup_time": 0.0
    },
    "bench_typed_list.ReductionSuite.time_execute_reduction_sum_no_fastmath": {
        "code": "class ReductionSuite:\n    def time_execute_reduction_sum_no_fastmath(self):\n        self.reduction_sum_no_fastmath(self.tl)\n\n    def setup(self):\n        raise NotImplementedError",
        "min_run_count": 5,
        "name": "bench_typed_list.ReductionSuite.time_execute_reduction_sum_no_fastmath",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "6417a028c49e72b68316091b3542923b401b23f4deb8210b04feb5b308c2b053",
        "warmup_time": 0.0
    },
    "bench_typed_list.SortSuite.time_compile_sort": {
        "code": "class SortSuite:\n    def time_compile_sort(self):\n        self.dispatcher.compile(self.signature)\n\n    def setup(self):\n        self.tl = make_random_typed_list_int(SIZE)\n        self.tl.sort()\n        self.dispatcher = dispatcher_registry['cpu'](_sort.py_func)\n        self.signature = Signature(none,\n                                   [ListType(int64), none, boolean],\n                                   None)\n        clear_dispatcher(self.dispatcher)",
        "min_run_count": 5,
        "name": "bench_typed_list.SortSuite.time_compile_sort",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "906944e2068542c9ed788fb068da2f614c47b9fd8d52be7ca4e8edee41165cab",
        "warmup_time": 0.0
    },
    "bench_typed_list.SortSuite.time_execute_sort": {
        "code": "class SortSuite:\n    def time_execute_sort(self):\n        self.tl.sort()\n\n    def setup(self):\n        self.tl = make_random_typed_list_int(SIZE)\n        self.tl.sort()\n        self.dispatcher = dispatcher_registry['cpu'](_sort.py_func)\n        self.signature = Signature(none,\n                                   [ListType(int64), none, boolean],\n                                   None)\n        clear_dispatcher(self.dispatcher)",
        "min_run_count": 5,
        "name": "bench_typed_list.SortSuite.time_execute_sort",
        "number": 1,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 5,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "4b9a9c45fbe1cbec5ed46b38c36d45a17499b62956e68f875f6646ade8ca477c",
        "warmup_time": 0.0
    },
    "bench_vectorize.Vectorize.time_mul_complex128": {
        "code": "class <locals>:\n    def f(self):\n        func = globals()[fname]\n        func(self.samples[dtype], self.samples[dtype], self.out[dtype])\n\ndef setup():\n    global mul, rel_diff\n\n    from numba import vectorize\n\n    @vectorize([\"float32(float32, float32)\",\n                \"float64(float64, float64)\",\n                \"complex64(complex64, complex64)\",\n                \"complex128(complex128, complex128)\"])\n    def mul(x, y):\n        return x * y\n\n    @vectorize([\"float32(float32, float32)\",\n                \"float64(float64, float64)\"])\n    def rel_diff(x, y):\n        # XXX for float32 performance, we should write `np.float32(2)`, but\n        # that's not the natural way to write this code...\n        return 2 * (x - y) / (x + y)\n\nclass Vectorize:\n    def setup(self):\n        setup()\n        self.samples = {}\n        self.out = {}\n        for dtype in self.dtypes:\n            self.samples[dtype] = np.linspace(0.1, 1, self.n, dtype=dtype)\n            self.out[dtype] = np.zeros(self.n, dtype=dtype)",
        "min_run_count": 2,
        "name": "bench_vectorize.Vectorize.time_mul_complex128",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "5fa667beeb57515700d2b77e2ce9f6439ff228b071091fa11ea71b68ada86079",
        "warmup_time": -1
    },
    "bench_vectorize.Vectorize.time_mul_complex64": {
        "code": "class <locals>:\n    def f(self):\n        func = globals()[fname]\n        func(self.samples[dtype], self.samples[dtype], self.out[dtype])\n\ndef setup():\n    global mul, rel_diff\n\n    from numba import vectorize\n\n    @vectorize([\"float32(float32, float32)\",\n                \"float64(float64, float64)\",\n                \"complex64(complex64, complex64)\",\n                \"complex128(complex128, complex128)\"])\n    def mul(x, y):\n        return x * y\n\n    @vectorize([\"float32(float32, float32)\",\n                \"float64(float64, float64)\"])\n    def rel_diff(x, y):\n        # XXX for float32 performance, we should write `np.float32(2)`, but\n        # that's not the natural way to write this code...\n        return 2 * (x - y) / (x + y)\n\nclass Vectorize:\n    def setup(self):\n        setup()\n        self.samples = {}\n        self.out = {}\n        for dtype in self.dtypes:\n            self.samples[dtype] = np.linspace(0.1, 1, self.n, dtype=dtype)\n            self.out[dtype] = np.zeros(self.n, dtype=dtype)",
        "min_run_count": 2,
        "name": "bench_vectorize.Vectorize.time_mul_complex64",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "5fa667beeb57515700d2b77e2ce9f6439ff228b071091fa11ea71b68ada86079",
        "warmup_time": -1
    },
    "bench_vectorize.Vectorize.time_mul_float32": {
        "code": "class <locals>:\n    def f(self):\n        func = globals()[fname]\n        func(self.samples[dtype], self.samples[dtype], self.out[dtype])\n\ndef setup():\n    global mul, rel_diff\n\n    from numba import vectorize\n\n    @vectorize([\"float32(float32, float32)\",\n                \"float64(float64, float64)\",\n                \"complex64(complex64, complex64)\",\n                \"complex128(complex128, complex128)\"])\n    def mul(x, y):\n        return x * y\n\n    @vectorize([\"float32(float32, float32)\",\n                \"float64(float64, float64)\"])\n    def rel_diff(x, y):\n        # XXX for float32 performance, we should write `np.float32(2)`, but\n        # that's not the natural way to write this code...\n        return 2 * (x - y) / (x + y)\n\nclass Vectorize:\n    def setup(self):\n        setup()\n        self.samples = {}\n        self.out = {}\n        for dtype in self.dtypes:\n            self.samples[dtype] = np.linspace(0.1, 1, self.n, dtype=dtype)\n            self.out[dtype] = np.zeros(self.n, dtype=dtype)",
        "min_run_count": 2,
        "name": "bench_vectorize.Vectorize.time_mul_float32",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "5fa667beeb57515700d2b77e2ce9f6439ff228b071091fa11ea71b68ada86079",
        "warmup_time": -1
    },
    "bench_vectorize.Vectorize.time_mul_float64": {
        "code": "class <locals>:\n    def f(self):\n        func = globals()[fname]\n        func(self.samples[dtype], self.samples[dtype], self.out[dtype])\n\ndef setup():\n    global mul, rel_diff\n\n    from numba import vectorize\n\n    @vectorize([\"float32(float32, float32)\",\n                \"float64(float64, float64)\",\n                \"complex64(complex64, complex64)\",\n                \"complex128(complex128, complex128)\"])\n    def mul(x, y):\n        return x * y\n\n    @vectorize([\"float32(float32, float32)\",\n                \"float64(float64, float64)\"])\n    def rel_diff(x, y):\n        # XXX for float32 performance, we should write `np.float32(2)`, but\n        # that's not the natural way to write this code...\n        return 2 * (x - y) / (x + y)\n\nclass Vectorize:\n    def setup(self):\n        setup()\n        self.samples = {}\n        self.out = {}\n        for dtype in self.dtypes:\n            self.samples[dtype] = np.linspace(0.1, 1, self.n, dtype=dtype)\n            self.out[dtype] = np.zeros(self.n, dtype=dtype)",
        "min_run_count": 2,
        "name": "bench_vectorize.Vectorize.time_mul_float64",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "5fa667beeb57515700d2b77e2ce9f6439ff228b071091fa11ea71b68ada86079",
        "warmup_time": -1
    },
    "bench_vectorize.Vectorize.time_rel_diff_float32": {
        "code": "class <locals>:\n    def f(self):\n        func = globals()[fname]\n        func(self.samples[dtype], self.samples[dtype], self.out[dtype])\n\ndef setup():\n    global mul, rel_diff\n\n    from numba import vectorize\n\n    @vectorize([\"float32(float32, float32)\",\n                \"float64(float64, float64)\",\n                \"complex64(complex64, complex64)\",\n                \"complex128(complex128, complex128)\"])\n    def mul(x, y):\n        return x * y\n\n    @vectorize([\"float32(float32, float32)\",\n                \"float64(float64, float64)\"])\n    def rel_diff(x, y):\n        # XXX for float32 performance, we should write `np.float32(2)`, but\n        # that's not the natural way to write this code...\n        return 2 * (x - y) / (x + y)\n\nclass Vectorize:\n    def setup(self):\n        setup()\n        self.samples = {}\n        self.out = {}\n        for dtype in self.dtypes:\n            self.samples[dtype] = np.linspace(0.1, 1, self.n, dtype=dtype)\n            self.out[dtype] = np.zeros(self.n, dtype=dtype)",
        "min_run_count": 2,
        "name": "bench_vectorize.Vectorize.time_rel_diff_float32",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "5fa667beeb57515700d2b77e2ce9f6439ff228b071091fa11ea71b68ada86079",
        "warmup_time": -1
    },
    "bench_vectorize.Vectorize.time_rel_diff_float64": {
        "code": "class <locals>:\n    def f(self):\n        func = globals()[fname]\n        func(self.samples[dtype], self.samples[dtype], self.out[dtype])\n\ndef setup():\n    global mul, rel_diff\n\n    from numba import vectorize\n\n    @vectorize([\"float32(float32, float32)\",\n                \"float64(float64, float64)\",\n                \"complex64(complex64, complex64)\",\n                \"complex128(complex128, complex128)\"])\n    def mul(x, y):\n        return x * y\n\n    @vectorize([\"float32(float32, float32)\",\n                \"float64(float64, float64)\"])\n    def rel_diff(x, y):\n        # XXX for float32 performance, we should write `np.float32(2)`, but\n        # that's not the natural way to write this code...\n        return 2 * (x - y) / (x + y)\n\nclass Vectorize:\n    def setup(self):\n        setup()\n        self.samples = {}\n        self.out = {}\n        for dtype in self.dtypes:\n            self.samples[dtype] = np.linspace(0.1, 1, self.n, dtype=dtype)\n            self.out[dtype] = np.zeros(self.n, dtype=dtype)",
        "min_run_count": 2,
        "name": "bench_vectorize.Vectorize.time_rel_diff_float64",
        "number": 0,
        "param_names": [],
        "params": [],
        "processes": 2,
        "repeat": 0,
        "sample_time": 0.01,
        "timeout": 60.0,
        "type": "time",
        "unit": "seconds",
        "version": "5fa667beeb57515700d2b77e2ce9f6439ff228b071091fa11ea71b68ada86079",
        "warmup_time": -1
    },
    "version": 2
}